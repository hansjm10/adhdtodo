diff --git a/app/(tabs)/_layout.tsx b/app/(tabs)/_layout.tsx
index f9dfa9a..01b32ec 100644
--- a/app/(tabs)/_layout.tsx
+++ b/app/(tabs)/_layout.tsx
@@ -63,9 +63,13 @@ export default function TabLayout() {
     try {
       const user = await UserStorageService.getCurrentUser();
       if (user) {
-        const notifications = await NotificationService.getNotificationsForUser(user.id);
-        const unread = notifications.filter((n) => !n.read).length;
-        setUnreadCount(unread);
+        const result = await NotificationService.getNotificationsForUser(user.id);
+        if (result.success && result.data) {
+          const unread = result.data.filter((n) => !n.read).length;
+          setUnreadCount(unread);
+        } else {
+          setUnreadCount(0);
+        }
       }
     } catch (error) {
       // Log error but don't disrupt UI - notification count is non-critical
diff --git a/app/notifications/index.tsx b/app/notifications/index.tsx
index d0cc7dd..33e7d79 100644
--- a/app/notifications/index.tsx
+++ b/app/notifications/index.tsx
@@ -50,12 +50,16 @@ const NotificationListScreen = () => {
       const user = await UserStorageService.getCurrentUser();
       if (user) {
         setCurrentUser(user);
-        const userNotifications = await NotificationService.getNotificationsForUser(user.id);
-        // Sort by timestamp, newest first
-        const sortedNotifications = userNotifications.sort(
-          (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime(),
-        );
-        setNotifications(sortedNotifications);
+        const result = await NotificationService.getNotificationsForUser(user.id);
+        if (result.success && result.data) {
+          // Sort by timestamp, newest first
+          const sortedNotifications = result.data.sort(
+            (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime(),
+          );
+          setNotifications(sortedNotifications);
+        } else {
+          setNotifications([]);
+        }
       }
     } catch (error) {
       // Error loading notifications
diff --git a/app/profile/partnership/assign.tsx b/app/profile/partnership/assign.tsx
index 2ac7453..9bb52fd 100644
--- a/app/profile/partnership/assign.tsx
+++ b/app/profile/partnership/assign.tsx
@@ -126,8 +126,10 @@ const TaskAssignmentScreen = () => {
       setCurrentUser(user);
 
       if (user) {
-        const activePartnership = await PartnershipService.getActivePartnership(user.id);
-        setPartnership(activePartnership);
+        const partnershipResult = await PartnershipService.getActivePartnership(user.id);
+        if (partnershipResult.success && partnershipResult.data !== undefined) {
+          setPartnership(partnershipResult.data);
+        }
       }
     } catch (error) {
       Alert.alert('Error', 'Failed to load user data');
diff --git a/app/profile/partnership/dashboard.tsx b/app/profile/partnership/dashboard.tsx
index a8d0acf..02fb2a7 100644
--- a/app/profile/partnership/dashboard.tsx
+++ b/app/profile/partnership/dashboard.tsx
@@ -136,10 +136,11 @@ const PartnerDashboardScreen = () => {
       setCurrentUser(user);
 
       if (user) {
-        const activePartnership = await PartnershipService.getActivePartnership(user.id);
-        setPartnership(activePartnership);
+        const partnershipResult = await PartnershipService.getActivePartnership(user.id);
+        if (partnershipResult.success && partnershipResult.data) {
+          setPartnership(partnershipResult.data);
 
-        if (activePartnership) {
+          const activePartnership = partnershipResult.data;
           const partnerId =
             activePartnership.adhdUserId === user.id
               ? activePartnership.partnerId
diff --git a/app/profile/partnership/index.tsx b/app/profile/partnership/index.tsx
index 0d8f041..3b0f6ba 100644
--- a/app/profile/partnership/index.tsx
+++ b/app/profile/partnership/index.tsx
@@ -66,10 +66,11 @@ const PartnershipScreen = () => {
       setCurrentUser(user);
 
       if (user) {
-        const activePartnership = await PartnershipService.getActivePartnership(user.id);
-        setPartnership(activePartnership);
+        const partnershipResult = await PartnershipService.getActivePartnership(user.id);
+        if (partnershipResult.success && partnershipResult.data) {
+          setPartnership(partnershipResult.data);
+          const activePartnership = partnershipResult.data;
 
-        if (activePartnership) {
           const partnerId =
             activePartnership.adhdUserId === user.id
               ? activePartnership.partnerId
@@ -122,13 +123,14 @@ const PartnershipScreen = () => {
       const invitedRole: UserRole =
         currentUser.role === USER_ROLE.ADHD_USER ? USER_ROLE.PARTNER : USER_ROLE.ADHD_USER;
 
-      const newPartnership = await PartnershipService.createPartnershipInvite(
+      const partnershipResult = await PartnershipService.createPartnershipInvite(
         currentUser.id,
         invitedRole,
       );
 
-      if (newPartnership) {
-        setInviteCode(newPartnership.inviteCode);
+      if (partnershipResult.success && partnershipResult.data) {
+        const newPartnership = partnershipResult.data;
+        setInviteCode(newPartnership.inviteCode || null);
         Alert.alert(
           'Invite Created!',
           `Your invite code is: ${newPartnership.inviteCode}\n\nShare this code with your ${
diff --git a/app/profile/partnership/invite.tsx b/app/profile/partnership/invite.tsx
index f33cdd4..361049f 100644
--- a/app/profile/partnership/invite.tsx
+++ b/app/profile/partnership/invite.tsx
@@ -111,7 +111,9 @@ const PartnerInviteScreen = () => {
           },
         ]);
       } else {
-        Alert.alert('Error', result.error ?? 'Failed to accept invite');
+        const errorMessage =
+          result.error?.message ?? result.error?.toString() ?? 'Failed to accept invite';
+        Alert.alert('Error', errorMessage);
       }
     } catch (error) {
       Alert.alert('Error', 'Something went wrong. Please try again.');
diff --git a/app/settings.tsx b/app/settings.tsx
index 3cee026..85fa7ee 100644
--- a/app/settings.tsx
+++ b/app/settings.tsx
@@ -35,8 +35,10 @@ const SettingsScreen = () => {
   }, []);
 
   const loadSettings = async () => {
-    const loaded = await settingsService.loadSettings();
-    setSettings(loaded);
+    const result = await settingsService.loadSettings();
+    if (result.success && result.data) {
+      setSettings(result.data);
+    }
   };
 
   const handleSave = async () => {
diff --git a/src/components/BiometricAuthScreen.tsx b/src/components/BiometricAuthScreen.tsx
index e54307f..99090a0 100644
--- a/src/components/BiometricAuthScreen.tsx
+++ b/src/components/BiometricAuthScreen.tsx
@@ -15,7 +15,7 @@ import {
   Platform,
 } from 'react-native';
 import type { BiometricSupport, SecuritySettings } from '../services/BiometricAuthService';
-import { BiometricAuthService } from '../services/BiometricAuthService';
+import BiometricAuthService from '../services/BiometricAuthService';
 import { PINAuthService } from '../services/PINAuthService';
 
 interface BiometricAuthScreenProps {
diff --git a/src/components/HyperfocusContainer.tsx b/src/components/HyperfocusContainer.tsx
index b34a992..a9d50c4 100644
--- a/src/components/HyperfocusContainer.tsx
+++ b/src/components/HyperfocusContainer.tsx
@@ -29,18 +29,20 @@ export const HyperfocusContainer: React.FC = () => {
   // Load settings on mount
   useEffect(() => {
     const loadSettings = async () => {
-      const settings = await SettingsService.loadSettings();
-      const pomodoroSettings = settings.pomodoro;
-
-      const workSec = pomodoroSettings.workDuration * 60;
-      const breakSec = pomodoroSettings.breakDuration * 60;
-      const longBreakSec = pomodoroSettings.longBreakDuration * 60;
-
-      setWorkDuration(workSec);
-      setBreakDuration(breakSec);
-      setLongBreakDuration(longBreakSec);
-      setLongBreakAfter(pomodoroSettings.longBreakAfter);
-      setTimeLeft(workSec);
+      const result = await SettingsService.loadSettings();
+      if (result.success && result.data) {
+        const pomodoroSettings = result.data.pomodoro;
+
+        const workSec = pomodoroSettings.workDuration * 60;
+        const breakSec = pomodoroSettings.breakDuration * 60;
+        const longBreakSec = pomodoroSettings.longBreakDuration * 60;
+
+        setWorkDuration(workSec);
+        setBreakDuration(breakSec);
+        setLongBreakDuration(longBreakSec);
+        setLongBreakAfter(pomodoroSettings.longBreakAfter);
+        setTimeLeft(workSec);
+      }
     };
 
     loadSettings().catch((error) => {
diff --git a/src/components/NotificationContainer.tsx b/src/components/NotificationContainer.tsx
index 2f0888a..8df2aeb 100644
--- a/src/components/NotificationContainer.tsx
+++ b/src/components/NotificationContainer.tsx
@@ -45,16 +45,22 @@ const NotificationContainer = () => {
     if (!currentUser) return;
 
     try {
-      const allNotifications = await NotificationService.getNotificationsForUser(currentUser.id);
+      const result = await NotificationService.getNotificationsForUser(currentUser.id);
+      if (!result.success || !result.data) {
+        return;
+      }
 
       // Filter for new notifications since last check
-      const newNotifications = allNotifications.filter((n) => {
+      const newNotifications = result.data.filter((n) => {
         // Handle both timestamp and createdAt properties
         const notificationTime = (() => {
-          if (n.timestamp) {
+          if ('timestamp' in n && n.timestamp) {
             return typeof n.timestamp === 'string' ? new Date(n.timestamp) : n.timestamp;
           }
-          return n.createdAt;
+          if ('createdAt' in n && n.createdAt) {
+            return n.createdAt;
+          }
+          return null;
         })();
         return !n.read && notificationTime && notificationTime > lastCheckRef.current;
       }) as NotificationWithData[];
diff --git a/src/components/TaskItem.tsx b/src/components/TaskItem.tsx
index 0b3a6a3..0d87617 100644
--- a/src/components/TaskItem.tsx
+++ b/src/components/TaskItem.tsx
@@ -114,9 +114,12 @@ const TaskItem = ({ task, onUpdate, onPress, currentUser, partner }: TaskItemPro
         await NotificationService.notifyTaskCompleted(updatedTask, currentUser);
 
         // Update partnership stats
-        const partnership = await PartnershipService.getActivePartnership(currentUser.id);
-        if (partnership) {
-          await PartnershipService.incrementPartnershipStat(partnership.id, 'tasksCompleted');
+        const partnershipResult = await PartnershipService.getActivePartnership(currentUser.id);
+        if (partnershipResult.success && partnershipResult.data) {
+          await PartnershipService.incrementPartnershipStat(
+            partnershipResult.data.id,
+            'tasksCompleted',
+          );
         }
       }
     }
diff --git a/src/components/TaskListView.tsx b/src/components/TaskListView.tsx
index cc21979..96a3d97 100644
--- a/src/components/TaskListView.tsx
+++ b/src/components/TaskListView.tsx
@@ -210,8 +210,10 @@ const TaskListView: React.FC<TaskListViewProps> = ({
 
   useEffect(() => {
     const loadSettings = async () => {
-      const settings = await settingsService.loadSettings();
-      setTaskLimit(settings.taskLimit);
+      const result = await settingsService.loadSettings();
+      if (result.success && result.data) {
+        setTaskLimit(result.data.taskLimit);
+      }
     };
     void loadSettings();
   }, []);
diff --git a/src/components/__tests__/BiometricAuthScreen.test.js b/src/components/__tests__/BiometricAuthScreen.test.js
index 8a0b2c3..9840212 100644
--- a/src/components/__tests__/BiometricAuthScreen.test.js
+++ b/src/components/__tests__/BiometricAuthScreen.test.js
@@ -5,11 +5,23 @@ import React from 'react';
 import { Alert } from 'react-native';
 import { render, fireEvent, waitFor } from '@testing-library/react-native';
 import BiometricAuthScreen from '../BiometricAuthScreen';
-import { BiometricAuthService } from '../../services/BiometricAuthService';
+import BiometricAuthService from '../../services/BiometricAuthService';
 import { PINAuthService } from '../../services/PINAuthService';
 
 // Mock services
-jest.mock('../../services/BiometricAuthService');
+jest.mock('../../services/BiometricAuthService', () => ({
+  __esModule: true,
+  default: {
+    checkBiometricSupport: jest.fn(),
+    authenticate: jest.fn(),
+    getSecuritySettings: jest.fn(),
+    setupAppSecurity: jest.fn(),
+    recordFailedAttempt: jest.fn(),
+    resetFailedAttempts: jest.fn(),
+    checkIfLocked: jest.fn(),
+  },
+  BiometricAuthService: jest.fn(),
+}));
 jest.mock('../../services/PINAuthService');
 
 // Mock Alert
diff --git a/src/contexts/AuthContext.tsx b/src/contexts/AuthContext.tsx
index 6bb0de0..02261ec 100644
--- a/src/contexts/AuthContext.tsx
+++ b/src/contexts/AuthContext.tsx
@@ -6,7 +6,7 @@ import React, { createContext, useContext, useState, useEffect, useRef, useCallb
 import type { AppStateStatus } from 'react-native';
 import { Alert, AppState } from 'react-native';
 import type { BiometricAuthResult, SecuritySettings } from '../services/BiometricAuthService';
-import { BiometricAuthService } from '../services/BiometricAuthService';
+import BiometricAuthService from '../services/BiometricAuthService';
 import { PINAuthService } from '../services/PINAuthService';
 import SecureLogger from '../services/SecureLogger';
 
diff --git a/src/contexts/NotificationContext.tsx b/src/contexts/NotificationContext.tsx
index 2fcb162..8eb6f10 100644
--- a/src/contexts/NotificationContext.tsx
+++ b/src/contexts/NotificationContext.tsx
@@ -82,10 +82,10 @@ export const NotificationProvider = ({ children }: NotificationProviderProps) =>
       setLoading(true);
       setError(null);
 
-      const loadedNotifications = await NotificationService.getNotificationsForUser(currentUser.id);
+      const result = await NotificationService.getNotificationsForUser(currentUser.id);
 
-      if (isMountedRef.current) {
-        setNotifications(loadedNotifications);
+      if (isMountedRef.current && result.success && result.data) {
+        setNotifications(result.data);
       }
     } catch (err) {
       if (isMountedRef.current) {
diff --git a/src/contexts/__tests__/AuthContext.test.js b/src/contexts/__tests__/AuthContext.test.js
index 3eb0cc1..564ccbf 100644
--- a/src/contexts/__tests__/AuthContext.test.js
+++ b/src/contexts/__tests__/AuthContext.test.js
@@ -5,12 +5,24 @@ import React from 'react';
 import { Alert } from 'react-native';
 import { renderHook, act, waitFor } from '@testing-library/react-native';
 import { AuthProvider, useAuth } from '../AuthContext';
-import { BiometricAuthService } from '../../services/BiometricAuthService';
+import BiometricAuthService from '../../services/BiometricAuthService';
 import { PINAuthService } from '../../services/PINAuthService';
 import SecureLogger from '../../services/SecureLogger';
 
 // Mock services
-jest.mock('../../services/BiometricAuthService');
+jest.mock('../../services/BiometricAuthService', () => ({
+  __esModule: true,
+  default: {
+    checkBiometricSupport: jest.fn(),
+    authenticate: jest.fn(),
+    getSecuritySettings: jest.fn(),
+    setupAppSecurity: jest.fn(),
+    recordFailedAttempt: jest.fn(),
+    resetFailedAttempts: jest.fn(),
+    checkIfLocked: jest.fn(),
+  },
+  BiometricAuthService: jest.fn(),
+}));
 jest.mock('../../services/PINAuthService');
 jest.mock('../../services/SecureLogger');
 
diff --git a/src/services/AuthService.ts b/src/services/AuthService.ts
index 6e33b1b..671dcd6 100644
--- a/src/services/AuthService.ts
+++ b/src/services/AuthService.ts
@@ -1,6 +1,7 @@
 // ABOUTME: Service for handling authentication including login, signup, and session management
 // Provides secure password-based authentication with session tokens
 
+import { BaseService } from './BaseService';
 import type { ICryptoService } from './CryptoService';
 import CryptoService from './CryptoService';
 import type { IUserStorageService } from './UserStorageService';
@@ -42,7 +43,7 @@ export interface IAuthService {
   detectAnomalousUsage(secureToken: SecureToken): boolean;
 }
 
-class AuthService implements IAuthService {
+class AuthService extends BaseService implements IAuthService {
   // Password validation rules
   static readonly PASSWORD_MIN_LENGTH = 8;
   static readonly PASSWORD_REQUIRE_UPPERCASE = true;
@@ -59,6 +60,7 @@ class AuthService implements IAuthService {
     userStorageService: IUserStorageService = UserStorageService,
     rateLimiter: IRateLimiter = RateLimiter,
   ) {
+    super('AuthService');
     this.cryptoService = cryptoService;
     this.userStorageService = userStorageService;
     this.rateLimiter = rateLimiter;
@@ -103,150 +105,172 @@ class AuthService implements IAuthService {
 
   // Sign up a new user
   async signUp(email: string, password: string, name: string, role: UserRole): Promise<AuthResult> {
-    try {
-      // Validate email format
-      if (!ValidationService.validateEmail(email)) {
-        throw new Error('Invalid email address');
-      }
+    const result = await this.wrapAsync(
+      'signUp',
+      async () => {
+        // Validate email format
+        if (!ValidationService.validateEmail(email)) {
+          throw new Error('Invalid email address');
+        }
 
-      // Check if user already exists
-      const existingUser = await this.userStorageService.getUserByEmail(email);
-      if (existingUser) {
-        throw new Error('An account already exists with this email');
-      }
+        // Check if user already exists
+        const existingUser = await this.userStorageService.getUserByEmail(email);
+        if (existingUser) {
+          throw new Error('An account already exists with this email');
+        }
 
-      // Validate password
-      const passwordValidation = this.validatePassword(password);
-      if (!passwordValidation.isValid) {
-        throw new Error(passwordValidation.errors.join('. '));
-      }
+        // Validate password
+        const passwordValidation = this.validatePassword(password);
+        if (!passwordValidation.isValid) {
+          throw new Error(passwordValidation.errors.join('. '));
+        }
 
-      // Generate salt and hash password
-      const salt = await this.cryptoService.generateSalt();
-      const passwordHash = await this.cryptoService.hashPassword(password, salt);
-
-      // Create new user without session token
-      const newUser = createUser({
-        email: email.toLowerCase(),
-        name,
-        role,
-        passwordHash,
-        passwordSalt: salt,
-        sessionToken: null, // Don't store plain token in user
-        lastLoginAt: new Date(),
-      });
+        // Generate salt and hash password
+        const salt = await this.cryptoService.generateSalt();
+        const passwordHash = await this.cryptoService.hashPassword(password, salt);
+
+        // Create new user without session token
+        const newUser = createUser({
+          email: email.toLowerCase(),
+          name,
+          role,
+          passwordHash,
+          passwordSalt: salt,
+          sessionToken: null, // Don't store plain token in user
+          lastLoginAt: new Date(),
+        });
 
-      // Validate user data
-      const validation = validateUser(newUser);
-      if (!validation.isValid) {
-        throw new Error(validation.errors.join('. '));
-      }
+        // Validate user data
+        const validation = validateUser(newUser);
+        if (!validation.isValid) {
+          throw new Error(validation.errors.join('. '));
+        }
 
-      // Save user first
-      await this.userStorageService.saveUser(newUser);
-      await this.userStorageService.setCurrentUser(newUser);
+        // Save user first
+        await this.userStorageService.saveUser(newUser);
+        await this.userStorageService.setCurrentUser(newUser);
 
-      // Create secure token for the new user
-      const secureToken = await this.createSecureToken(newUser.id);
-      await this.storeSecureToken(newUser.id, secureToken);
+        // Create secure token for the new user
+        const secureToken = await this.createSecureToken(newUser.id);
+        await this.storeSecureToken(newUser.id, secureToken);
 
-      // Generate reference token for API
-      const referenceToken = await this.cryptoService.generateToken(32);
-      await this.userStorageService.saveUserToken(referenceToken);
+        // Generate reference token for API
+        const referenceToken = await this.cryptoService.generateToken(32);
+        await this.userStorageService.saveUserToken(referenceToken);
 
+        return {
+          user: this.sanitizeUser(newUser),
+          token: referenceToken, // Return reference token for API
+        };
+      },
+      { email: email.toLowerCase(), role },
+    );
+
+    if (result.success && result.data) {
       return {
         success: true,
-        user: this.sanitizeUser(newUser),
-        token: referenceToken, // Return reference token for API
-      };
-    } catch (error) {
-      return {
-        success: false,
-        error: error instanceof Error ? error.message : 'Unknown error occurred',
+        user: result.data.user,
+        token: result.data.token,
       };
     }
+
+    return {
+      success: false,
+      error: result.error?.message ?? 'Unknown error occurred',
+    };
   }
 
   // Login an existing user
   async login(email: string, password: string): Promise<AuthResult> {
-    try {
-      // Validate inputs
-      if (!email || !password) {
-        throw new Error('Email and password are required');
-      }
+    const result = await this.wrapAsync(
+      'login',
+      async () => {
+        // Validate inputs
+        if (!email || !password) {
+          throw new Error('Email and password are required');
+        }
 
-      // Check rate limiting
-      if (!this.rateLimiter.canAttemptLogin(email)) {
-        const lockoutEnd = this.rateLimiter.getLockoutEndTime(email);
-        const minutesRemaining = lockoutEnd ? Math.ceil((lockoutEnd - Date.now()) / 60000) : 15;
-        throw new Error(
-          `Too many failed login attempts. Please try again in ${minutesRemaining} minutes.`,
-        );
-      }
+        // Check rate limiting
+        if (!this.rateLimiter.canAttemptLogin(email)) {
+          const lockoutEnd = this.rateLimiter.getLockoutEndTime(email);
+          const minutesRemaining = lockoutEnd ? Math.ceil((lockoutEnd - Date.now()) / 60000) : 15;
+          throw new Error(
+            `Too many failed login attempts. Please try again in ${minutesRemaining} minutes.`,
+          );
+        }
 
-      // Find user by email
-      const user = await this.userStorageService.getUserByEmail(email);
-      if (!user) {
-        throw new Error('Invalid email or password');
-      }
+        // Find user by email
+        const user = await this.userStorageService.getUserByEmail(email);
+        if (!user) {
+          throw new Error('Invalid email or password');
+        }
 
-      // Verify user has password credentials
-      if (!user.passwordHash || !user.passwordSalt) {
-        throw new Error('Invalid email or password');
-      }
+        // Verify user has password credentials
+        if (!user.passwordHash || !user.passwordSalt) {
+          throw new Error('Invalid email or password');
+        }
 
-      // Verify password
-      const isPasswordValid = await this.cryptoService.verifyPassword(
-        password,
-        user.passwordHash,
-        user.passwordSalt,
-      );
+        // Verify password
+        const isPasswordValid = await this.cryptoService.verifyPassword(
+          password,
+          user.passwordHash,
+          user.passwordSalt,
+        );
 
-      if (!isPasswordValid) {
-        this.rateLimiter.recordLoginAttempt(email, false);
-        throw new Error('Invalid email or password');
-      }
+        if (!isPasswordValid) {
+          this.rateLimiter.recordLoginAttempt(email, false);
+          throw new Error('Invalid email or password');
+        }
 
-      // Create secure token instead of plain token
-      const secureToken = await this.createSecureToken(user.id);
+        // Create secure token instead of plain token
+        const secureToken = await this.createSecureToken(user.id);
 
-      // Store secure token separately
-      await this.storeSecureToken(user.id, secureToken);
+        // Store secure token separately
+        await this.storeSecureToken(user.id, secureToken);
 
-      // Update user with timestamp only (no plain token)
-      const updatedUser = updateUser(user, {
-        sessionToken: null, // Don't store plain token in user object
-        lastLoginAt: new Date(),
-        lastActiveAt: new Date(),
-      });
+        // Update user with timestamp only (no plain token)
+        const updatedUser = updateUser(user, {
+          sessionToken: null, // Don't store plain token in user object
+          lastLoginAt: new Date(),
+          lastActiveAt: new Date(),
+        });
 
-      // Save updated user and set as current
-      await this.userStorageService.updateUser(updatedUser);
-      await this.userStorageService.setCurrentUser(updatedUser);
+        // Save updated user and set as current
+        await this.userStorageService.updateUser(updatedUser);
+        await this.userStorageService.setCurrentUser(updatedUser);
+
+        // Store a reference token for backward compatibility
+        const referenceToken = await this.cryptoService.generateToken(32);
+        await this.userStorageService.saveUserToken(referenceToken);
 
-      // Store a reference token for backward compatibility
-      const referenceToken = await this.cryptoService.generateToken(32);
-      await this.userStorageService.saveUserToken(referenceToken);
+        // Record successful login
+        this.rateLimiter.recordLoginAttempt(email, true);
 
-      // Record successful login
-      this.rateLimiter.recordLoginAttempt(email, true);
+        return {
+          user: this.sanitizeUser(updatedUser),
+          token: referenceToken, // Return reference token for API calls
+        };
+      },
+      { email: email.toLowerCase() },
+    );
 
+    if (result.success && result.data) {
       return {
         success: true,
-        user: this.sanitizeUser(updatedUser),
-        token: referenceToken, // Return reference token for API calls
-      };
-    } catch (error) {
-      return {
-        success: false,
-        error: error instanceof Error ? error.message : 'Unknown error occurred',
+        user: result.data.user,
+        token: result.data.token,
       };
     }
+
+    return {
+      success: false,
+      error: result.error?.message ?? 'Unknown error occurred',
+    };
   }
 
   // Verify current session
   async verifySession(): Promise<SessionVerificationResult> {
-    try {
+    const result = await this.wrapAsync('verifySession', async () => {
       const referenceToken = await this.userStorageService.getUserToken();
       if (!referenceToken) {
         return { isValid: false, reason: 'No session token' };
@@ -297,15 +321,21 @@ class AuthService implements IAuthService {
         isValid: true,
         user: this.sanitizeUser(updatedUser),
       };
-    } catch (error) {
-      SecureLogger.error('Session verification failed', { code: 'AUTH_SESSION_001' });
-      return { isValid: false, reason: 'Verification error' };
+    });
+
+    if (result.success && result.data) {
+      return result.data;
     }
+
+    if (result.error) {
+      this.logError('verifySession', result.error);
+    }
+    return { isValid: false, reason: 'Verification error' };
   }
 
   // Logout current user
   async logout(): Promise<{ success: boolean; error?: string }> {
-    try {
+    const result = await this.wrapAsync('logout', async () => {
       const currentUser = await this.userStorageService.getCurrentUser();
 
       if (currentUser) {
@@ -319,108 +349,124 @@ class AuthService implements IAuthService {
       // Clear stored session
       await this.userStorageService.logout();
 
+      return true;
+    });
+
+    if (result.success) {
       return { success: true };
-    } catch (error) {
-      SecureLogger.error('Logout operation failed', { code: 'AUTH_LOGOUT_001' });
-      return {
-        success: false,
-        error: error instanceof Error ? error.message : 'Unknown error occurred',
-      };
     }
+    return {
+      success: false,
+      error: result.error?.message ?? 'Unknown error occurred',
+    };
   }
 
   // Change password for current user
   async changePassword(currentPassword: string, newPassword: string): Promise<AuthResult> {
-    try {
-      const currentUser = await this.userStorageService.getCurrentUser();
-      if (!currentUser) {
-        throw new Error('No user logged in');
-      }
+    const result = await this.wrapAsync(
+      'changePassword',
+      async () => {
+        const currentUser = await this.userStorageService.getCurrentUser();
+        if (!currentUser) {
+          throw new Error('No user logged in');
+        }
 
-      // Verify current password
-      const isPasswordValid = await this.cryptoService.verifyPassword(
-        currentPassword,
-        currentUser.passwordHash!,
-        currentUser.passwordSalt!,
-      );
+        // Verify current password
+        const isPasswordValid = await this.cryptoService.verifyPassword(
+          currentPassword,
+          currentUser.passwordHash!,
+          currentUser.passwordSalt!,
+        );
 
-      if (!isPasswordValid) {
-        throw new Error('Current password is incorrect');
-      }
+        if (!isPasswordValid) {
+          throw new Error('Current password is incorrect');
+        }
 
-      // Validate new password
-      const passwordValidation = this.validatePassword(newPassword);
-      if (!passwordValidation.isValid) {
-        throw new Error(passwordValidation.errors.join('. '));
-      }
+        // Validate new password
+        const passwordValidation = this.validatePassword(newPassword);
+        if (!passwordValidation.isValid) {
+          throw new Error(passwordValidation.errors.join('. '));
+        }
 
-      // Generate new salt and hash
-      const salt = await this.cryptoService.generateSalt();
-      const passwordHash = await this.cryptoService.hashPassword(newPassword, salt);
+        // Generate new salt and hash
+        const salt = await this.cryptoService.generateSalt();
+        const passwordHash = await this.cryptoService.hashPassword(newPassword, salt);
 
-      // Generate new session token
-      const sessionToken = await this.cryptoService.generateSessionToken();
+        // Generate new session token
+        const sessionToken = await this.cryptoService.generateSessionToken();
 
-      // Update user
-      const updatedUser = updateUser(currentUser, {
-        passwordHash,
-        passwordSalt: salt,
-        sessionToken,
-        updatedAt: new Date(),
-      });
+        // Update user
+        const updatedUser = updateUser(currentUser, {
+          passwordHash,
+          passwordSalt: salt,
+          sessionToken,
+          updatedAt: new Date(),
+        });
 
-      await this.userStorageService.updateUser(updatedUser);
-      await this.userStorageService.setCurrentUser(updatedUser);
-      await this.userStorageService.saveUserToken(sessionToken);
+        await this.userStorageService.updateUser(updatedUser);
+        await this.userStorageService.setCurrentUser(updatedUser);
+        await this.userStorageService.saveUserToken(sessionToken);
+
+        return true;
+      },
+      { userId: (await this.userStorageService.getCurrentUser())?.id },
+    );
 
+    if (result.success) {
       return { success: true };
-    } catch (error) {
-      return {
-        success: false,
-        error: error instanceof Error ? error.message : 'Unknown error occurred',
-      };
     }
+    return {
+      success: false,
+      error: result.error?.message ?? 'Unknown error occurred',
+    };
   }
 
   // Reset password (for forgot password flow - simplified version)
   async resetPassword(email: string, newPassword: string): Promise<PasswordResetResult> {
-    try {
-      const user = await this.userStorageService.getUserByEmail(email);
-      if (!user) {
-        // Don't reveal if user exists
-        return { success: true, message: 'If an account exists, the password has been reset' };
-      }
+    const result = await this.wrapAsync(
+      'resetPassword',
+      async () => {
+        const user = await this.userStorageService.getUserByEmail(email);
+        if (!user) {
+          // Don't reveal if user exists
+          return { message: 'If an account exists, the password has been reset' };
+        }
 
-      // Validate new password
-      const passwordValidation = this.validatePassword(newPassword);
-      if (!passwordValidation.isValid) {
-        throw new Error(passwordValidation.errors.join('. '));
-      }
+        // Validate new password
+        const passwordValidation = this.validatePassword(newPassword);
+        if (!passwordValidation.isValid) {
+          throw new Error(passwordValidation.errors.join('. '));
+        }
 
-      // Generate new salt and hash
-      const salt = await this.cryptoService.generateSalt();
-      const passwordHash = await this.cryptoService.hashPassword(newPassword, salt);
+        // Generate new salt and hash
+        const salt = await this.cryptoService.generateSalt();
+        const passwordHash = await this.cryptoService.hashPassword(newPassword, salt);
 
-      // Update user (clear session token to force re-login)
-      const updatedUser = updateUser(user, {
-        passwordHash,
-        passwordSalt: salt,
-        sessionToken: null,
-        updatedAt: new Date(),
-      });
+        // Update user (clear session token to force re-login)
+        const updatedUser = updateUser(user, {
+          passwordHash,
+          passwordSalt: salt,
+          sessionToken: null,
+          updatedAt: new Date(),
+        });
 
-      await this.userStorageService.updateUser(updatedUser);
+        await this.userStorageService.updateUser(updatedUser);
 
+        return { message: 'If an account exists, the password has been reset' };
+      },
+      { email: email.toLowerCase() },
+    );
+
+    if (result.success && result.data) {
       return {
         success: true,
-        message: 'If an account exists, the password has been reset',
-      };
-    } catch (error) {
-      return {
-        success: false,
-        error: error instanceof Error ? error.message : 'Unknown error occurred',
+        message: result.data.message,
       };
     }
+    return {
+      success: false,
+      error: result.error?.message ?? 'Unknown error occurred',
+    };
   }
 
   // Remove sensitive fields from user object
@@ -467,7 +513,7 @@ class AuthService implements IAuthService {
 
   // Validate a secure token with device binding checks
   async validateSecureToken(secureToken: SecureToken, providedToken: string): Promise<boolean> {
-    try {
+    const result = await this.wrapAsync('validateSecureToken', async () => {
       // Check device binding
       const currentDeviceId = await this.getDeviceId();
       if (secureToken.deviceId !== currentDeviceId) {
@@ -499,10 +545,12 @@ class AuthService implements IAuthService {
       );
 
       return decryptedToken === providedToken;
-    } catch (error) {
-      SecureLogger.error('Token validation failed', { code: 'AUTH_TOKEN_002' });
-      return false;
+    });
+
+    if (result.success && result.data !== undefined) {
+      return result.data;
     }
+    return false;
   }
 
   // Store token separately from user data
@@ -518,7 +566,7 @@ class AuthService implements IAuthService {
 
   // Retrieve secure token
   async getSecureToken(userId: string): Promise<SecureToken | null> {
-    try {
+    const result = await this.wrapAsync('getSecureToken', async () => {
       const tokenKey = `auth_token_${userId}`;
       const tokenData = await SecureStore.getItemAsync(tokenKey, {
         requireAuthentication: true,
@@ -536,10 +584,12 @@ class AuthService implements IAuthService {
       token.lastUsedAt = new Date(token.lastUsedAt);
 
       return token;
-    } catch (error) {
-      SecureLogger.error('Failed to retrieve secure token', { code: 'AUTH_TOKEN_003' });
-      return null;
+    });
+
+    if (result.success && result.data !== undefined) {
+      return result.data;
     }
+    return null;
   }
 
   // Rotate token and invalidate old sessions
@@ -553,9 +603,7 @@ class AuthService implements IAuthService {
       try {
         await this.invalidateOtherSessions(userId);
       } catch (err: unknown) {
-        if (global.__DEV__ && err) {
-          console.error('Failed to invalidate other sessions:', String(err));
-        }
+        this.logError('invalidateOtherSessions', err);
       }
     };
 
@@ -569,7 +617,7 @@ class AuthService implements IAuthService {
   async getOrCreateDeviceKey(): Promise<string> {
     const deviceKeyName = 'device_encryption_key';
 
-    try {
+    const result = await this.wrapAsync('getOrCreateDeviceKey', async () => {
       // Try to get existing device key
       const existingKey = await SecureStore.getItemAsync(deviceKeyName, {
         requireAuthentication: true,
@@ -591,10 +639,12 @@ class AuthService implements IAuthService {
       });
 
       return deviceKey;
-    } catch (error) {
-      SecureLogger.error('Failed to manage device key', { code: 'AUTH_DEVICE_KEY_001' });
-      throw new Error('Failed to manage device encryption key');
+    });
+
+    if (result.success && result.data) {
+      return result.data;
     }
+    throw new Error('Failed to manage device encryption key');
   }
 
   // Get unique device identifier
@@ -603,7 +653,7 @@ class AuthService implements IAuthService {
     // For now, we'll use a hash of crypto-generated data stored securely
     const deviceIdKey = 'device_unique_id';
 
-    try {
+    const result = await this.wrapAsync('getDeviceId', async () => {
       let deviceId = await SecureStore.getItemAsync(deviceIdKey);
 
       if (!deviceId) {
@@ -614,10 +664,12 @@ class AuthService implements IAuthService {
       }
 
       return deviceId || 'unknown-device';
-    } catch (error) {
-      SecureLogger.error('Failed to get device ID', { code: 'AUTH_DEVICE_ID_001' });
-      return 'unknown-device';
+    });
+
+    if (result.success && result.data) {
+      return result.data;
     }
+    return 'unknown-device';
   }
 
   // Get installation ID
@@ -625,7 +677,7 @@ class AuthService implements IAuthService {
     // Similar to device ID but specific to this app installation
     const installIdKey = 'app_installation_id';
 
-    try {
+    const result = await this.wrapAsync('getInstallationId', async () => {
       let installationId = await SecureStore.getItemAsync(installIdKey);
 
       if (!installationId) {
@@ -635,10 +687,12 @@ class AuthService implements IAuthService {
       }
 
       return installationId || 'unknown-installation';
-    } catch (error) {
-      SecureLogger.error('Failed to get installation ID', { code: 'AUTH_INSTALL_ID_001' });
-      return 'unknown-installation';
+    });
+
+    if (result.success && result.data) {
+      return result.data;
     }
+    return 'unknown-installation';
   }
 
   // Invalidate other sessions (placeholder for future implementation)
@@ -703,4 +757,5 @@ class AuthService implements IAuthService {
   }
 }
 
+export { AuthService };
 export default new AuthService();
diff --git a/src/services/BaseService.ts b/src/services/BaseService.ts
index 69fdba5..f5505c2 100644
--- a/src/services/BaseService.ts
+++ b/src/services/BaseService.ts
@@ -148,6 +148,9 @@ export abstract class BaseService {
         update: 'Failed to update. Please try again.',
         sync: 'Sync failed. Please check your connection.',
         auth: 'Authentication failed. Please try again.',
+        partnership: 'Partnership operation failed. Please try again.',
+        notification: 'Notification failed. Please check your settings.',
+        biometric: 'Biometric authentication failed. Please try again.',
       };
 
       // Return operation-specific message or generic one
diff --git a/src/services/BiometricAuthService.ts b/src/services/BiometricAuthService.ts
index cc0a6c9..c712d32 100644
--- a/src/services/BiometricAuthService.ts
+++ b/src/services/BiometricAuthService.ts
@@ -2,7 +2,9 @@
 // Touch ID, fingerprint, and iris recognition with secure fallback options
 
 import * as LocalAuthentication from 'expo-local-authentication';
-import { SecureStorageService } from './SecureStorageService';
+import { BaseService } from './BaseService';
+import type { ISecureStorageService } from './SecureStorageService';
+import SecureStorageService from './SecureStorageService';
 import type { BiometricAuthResult } from '../types/auth.types';
 
 // Re-exported for backward compatibility - types now live in auth.types.ts
@@ -31,107 +33,191 @@ const DEFAULT_SECURITY_SETTINGS: SecuritySettings = {
   maxFailedAttempts: 5,
 };
 
-export class BiometricAuthService {
+export interface IBiometricAuthService {
+  checkBiometricSupport(): Promise<BiometricSupport>;
+  authenticate(reason?: string): Promise<BiometricAuthResult>;
+  setupAppSecurity(settings: SecuritySettings): Promise<void>;
+  getSecuritySettings(): Promise<SecuritySettings>;
+  recordFailedAttempt(): Promise<number>;
+  resetFailedAttempts(): Promise<void>;
+  checkIfLocked(): Promise<boolean>;
+}
+
+class BiometricAuthService extends BaseService implements IBiometricAuthService {
+  private secureStorageService: ISecureStorageService;
+
+  constructor(secureStorageService: ISecureStorageService = SecureStorageService) {
+    super('BiometricAuthService');
+    this.secureStorageService = secureStorageService;
+  }
   /**
    * Check device biometric capabilities and enrollment status
    */
-  static async checkBiometricSupport(): Promise<BiometricSupport> {
-    const hasHardware = await LocalAuthentication.hasHardwareAsync();
-    const supportedTypes = await LocalAuthentication.supportedAuthenticationTypesAsync();
-    const isEnrolled = await LocalAuthentication.isEnrolledAsync();
+  async checkBiometricSupport(): Promise<BiometricSupport> {
+    const result = await this.wrapAsync('checkBiometricSupport', async () => {
+      const hasHardware = await LocalAuthentication.hasHardwareAsync();
+      const supportedTypes = await LocalAuthentication.supportedAuthenticationTypesAsync();
+      const isEnrolled = await LocalAuthentication.isEnrolledAsync();
+
+      return {
+        hasHardware,
+        isEnrolled,
+        supportedTypes,
+        biometricType: this.getBiometricType(supportedTypes),
+      };
+    });
+
+    if (result.success && result.data) {
+      return result.data;
+    }
 
+    // Return safe defaults on error
     return {
-      hasHardware,
-      isEnrolled,
-      supportedTypes,
-      biometricType: this.getBiometricType(supportedTypes),
+      hasHardware: false,
+      isEnrolled: false,
+      supportedTypes: [],
+      biometricType: 'none',
     };
   }
 
   /**
    * Authenticate user with biometric prompt
    */
-  static async authenticate(reason?: string): Promise<BiometricAuthResult> {
-    try {
-      const result = await LocalAuthentication.authenticateAsync({
-        promptMessage: reason ?? 'Authenticate to access your ADHD Todo data',
-        cancelLabel: 'Cancel',
-        fallbackLabel: 'Use PIN',
-        disableDeviceFallback: false,
-      });
-
-      if (result.success) {
-        await this.recordSuccessfulAuth();
-        await this.resetFailedAttempts();
-        return { success: true };
-      }
+  async authenticate(reason?: string): Promise<BiometricAuthResult> {
+    const result = await this.wrapAsync(
+      'authenticate',
+      async () => {
+        const authResult = await LocalAuthentication.authenticateAsync({
+          promptMessage: reason ?? 'Authenticate to access your ADHD Todo data',
+          cancelLabel: 'Cancel',
+          fallbackLabel: 'Use PIN',
+          disableDeviceFallback: false,
+        });
 
-      return {
-        success: false,
-        error: result.error,
-        warning: result.warning,
-      };
-    } catch (error) {
-      return {
-        success: false,
-        error: 'Authentication failed',
-      };
+        if (authResult.success) {
+          await this.recordSuccessfulAuth();
+          await this.resetFailedAttempts();
+          return { success: true };
+        }
+
+        return {
+          success: false,
+          error: authResult.error,
+          warning: authResult.warning,
+        };
+      },
+      { reason },
+    );
+
+    if (result.success && result.data) {
+      return result.data;
     }
+
+    return {
+      success: false,
+      error: result.error?.message ?? 'Authentication failed',
+    };
   }
 
   /**
    * Configure app-wide security settings
    */
-  static async setupAppSecurity(settings: SecuritySettings): Promise<void> {
-    await SecureStorageService.saveSecure('SECURITY_SETTINGS', settings);
+  async setupAppSecurity(settings: SecuritySettings): Promise<void> {
+    const result = await this.wrapAsync(
+      'setupAppSecurity',
+      async () => {
+        await this.secureStorageService.saveSecure('SECURITY_SETTINGS', settings);
 
-    if (settings.requireAuthOnLaunch) {
-      await this.enableLaunchAuthentication();
-    }
+        if (settings.requireAuthOnLaunch) {
+          await this.enableLaunchAuthentication();
+        }
+
+        if (settings.sensitiveDataAuth) {
+          await this.enableSensitiveDataProtection();
+        }
+      },
+      { settings },
+    );
 
-    if (settings.sensitiveDataAuth) {
-      await this.enableSensitiveDataProtection();
+    if (!result.success) {
+      throw new Error(result.error?.message ?? 'Failed to setup app security');
     }
   }
 
   /**
    * Get current security settings
    */
-  static async getSecuritySettings(): Promise<SecuritySettings> {
-    const settings = await SecureStorageService.getSecure<SecuritySettings>('SECURITY_SETTINGS');
-    return settings ?? DEFAULT_SECURITY_SETTINGS;
+  async getSecuritySettings(): Promise<SecuritySettings> {
+    const result = await this.wrapAsync('getSecuritySettings', async () => {
+      const settings =
+        await this.secureStorageService.getSecure<SecuritySettings>('SECURITY_SETTINGS');
+      return settings ?? DEFAULT_SECURITY_SETTINGS;
+    });
+
+    if (result.success && result.data) {
+      return result.data;
+    }
+
+    return DEFAULT_SECURITY_SETTINGS;
   }
 
   /**
    * Record a failed authentication attempt
    */
-  static async recordFailedAttempt(): Promise<number> {
-    const attempts = (await SecureStorageService.getSecure<number>('FAILED_AUTH_ATTEMPTS')) ?? 0;
-    const newCount = attempts + 1;
-    await SecureStorageService.saveSecure('FAILED_AUTH_ATTEMPTS', newCount);
-    return newCount;
+  async recordFailedAttempt(): Promise<number> {
+    const result = await this.wrapAsync('recordFailedAttempt', async () => {
+      const attempts =
+        (await this.secureStorageService.getSecure<number>('FAILED_AUTH_ATTEMPTS')) ?? 0;
+      const newCount = attempts + 1;
+      await this.secureStorageService.saveSecure('FAILED_AUTH_ATTEMPTS', newCount);
+      return newCount;
+    });
+
+    if (result.success && result.data !== undefined) {
+      return result.data;
+    }
+
+    // Return 1 as safe default on error
+    return 1;
   }
 
   /**
    * Reset failed authentication attempts counter
    */
-  static async resetFailedAttempts(): Promise<void> {
-    await SecureStorageService.deleteSecure('FAILED_AUTH_ATTEMPTS');
+  async resetFailedAttempts(): Promise<void> {
+    const result = await this.wrapAsync('resetFailedAttempts', async () => {
+      await this.secureStorageService.deleteSecure('FAILED_AUTH_ATTEMPTS');
+    });
+
+    if (!result.success) {
+      // Log error but don't throw - this is a non-critical operation
+      this.logError('resetFailedAttempts', result.error);
+    }
   }
 
   /**
    * Check if authentication is locked due to too many failed attempts
    */
-  static async checkIfLocked(): Promise<boolean> {
-    const attempts = (await SecureStorageService.getSecure<number>('FAILED_AUTH_ATTEMPTS')) ?? 0;
-    const settings = await this.getSecuritySettings();
-    return attempts >= settings.maxFailedAttempts;
+  async checkIfLocked(): Promise<boolean> {
+    const result = await this.wrapAsync('checkIfLocked', async () => {
+      const attempts =
+        (await this.secureStorageService.getSecure<number>('FAILED_AUTH_ATTEMPTS')) ?? 0;
+      const settings = await this.getSecuritySettings();
+      return attempts >= settings.maxFailedAttempts;
+    });
+
+    if (result.success && result.data !== undefined) {
+      return result.data;
+    }
+
+    // Return false as safe default on error
+    return false;
   }
 
   /**
    * Determine the type of biometric authentication available
    */
-  private static getBiometricType(types: number[]): BiometricType {
+  private getBiometricType(types: number[]): BiometricType {
     if (types.includes(LocalAuthentication.AuthenticationType.FACIAL_RECOGNITION)) {
       return 'faceId';
     }
@@ -147,22 +233,25 @@ export class BiometricAuthService {
   /**
    * Record successful authentication timestamp
    */
-  private static async recordSuccessfulAuth(): Promise<void> {
+  private async recordSuccessfulAuth(): Promise<void> {
     const timestamp = new Date().toISOString();
-    await SecureStorageService.saveSecure('LAST_AUTH_SUCCESS', timestamp);
+    await this.secureStorageService.saveSecure('LAST_AUTH_SUCCESS', timestamp);
   }
 
   /**
    * Enable authentication requirement on app launch
    */
-  private static async enableLaunchAuthentication(): Promise<void> {
-    await SecureStorageService.saveSecure('LAUNCH_AUTH_ENABLED', true);
+  private async enableLaunchAuthentication(): Promise<void> {
+    await this.secureStorageService.saveSecure('LAUNCH_AUTH_ENABLED', true);
   }
 
   /**
    * Enable authentication for sensitive data access
    */
-  private static async enableSensitiveDataProtection(): Promise<void> {
-    await SecureStorageService.saveSecure('SENSITIVE_DATA_AUTH_ENABLED', true);
+  private async enableSensitiveDataProtection(): Promise<void> {
+    await this.secureStorageService.saveSecure('SENSITIVE_DATA_AUTH_ENABLED', true);
   }
 }
+
+export { BiometricAuthService };
+export default new BiometricAuthService();
diff --git a/src/services/NotificationService.ts b/src/services/NotificationService.ts
index 62c95ad..fbb551f 100644
--- a/src/services/NotificationService.ts
+++ b/src/services/NotificationService.ts
@@ -2,10 +2,10 @@
 // No local storage fallback, no manual cleanup - pure Supabase implementation
 
 import { supabase } from './SupabaseService';
+import { BaseService } from './BaseService';
 import { NOTIFICATION_TYPES } from '../constants/UserConstants';
 import UserStorageService from './UserStorageService';
-import SecureLogger from './SecureLogger';
-import type { Notification, NotificationTypes, User, Task } from '../types';
+import type { Notification, NotificationTypes, User, Task, Result } from '../types';
 import { NotificationPriority } from '../types';
 import type { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js';
 
@@ -14,23 +14,23 @@ export interface INotificationService {
     toUserId: string,
     type: NotificationTypes,
     data: Record<string, unknown>,
-  ): Promise<boolean>;
-  notifyTaskAssigned(task: Task, assignedByUser: User): Promise<boolean>;
-  notifyTaskStarted(task: Task, startedByUser: User): Promise<boolean>;
-  notifyTaskCompleted(task: Task, completedByUser: User): Promise<boolean>;
-  notifyTaskOverdue(task: Task): Promise<boolean>;
+  ): Promise<Result<boolean>>;
+  notifyTaskAssigned(task: Task, assignedByUser: User): Promise<Result<boolean>>;
+  notifyTaskStarted(task: Task, startedByUser: User): Promise<Result<boolean>>;
+  notifyTaskCompleted(task: Task, completedByUser: User): Promise<Result<boolean>>;
+  notifyTaskOverdue(task: Task): Promise<Result<boolean>>;
   sendEncouragement(
     fromUserId: string,
     toUserId: string,
     message: string,
     taskId?: string | null,
-  ): Promise<boolean>;
-  sendCheckIn(fromUserId: string, toUserId: string, message: string): Promise<boolean>;
-  getNotificationsForUser(userId: string): Promise<Notification[]>;
-  getUnreadNotificationCount(userId: string): Promise<number>;
-  markNotificationAsRead(notificationId: string): Promise<boolean>;
-  markAllNotificationsAsRead(userId: string): Promise<boolean>;
-  clearNotificationsForUser(userId: string): Promise<boolean>;
+  ): Promise<Result<boolean>>;
+  sendCheckIn(fromUserId: string, toUserId: string, message: string): Promise<Result<boolean>>;
+  getNotificationsForUser(userId: string): Promise<Result<Notification[]>>;
+  getUnreadNotificationCount(userId: string): Promise<Result<number>>;
+  markNotificationAsRead(notificationId: string): Promise<Result<boolean>>;
+  markAllNotificationsAsRead(userId: string): Promise<Result<boolean>>;
+  clearNotificationsForUser(userId: string): Promise<Result<boolean>>;
   subscribeToNotifications(
     userId: string,
     callback: (notification: Notification) => void,
@@ -52,9 +52,13 @@ interface DbNotification {
   expires_at?: string;
 }
 
-export class NotificationService implements INotificationService {
+export class NotificationService extends BaseService implements INotificationService {
   private subscriptions = new Map<string, RealtimeChannel>();
 
+  constructor() {
+    super('Notification');
+  }
+
   private transformDbNotificationToNotification(dbNotif: DbNotification): Notification {
     return {
       id: dbNotif.id,
@@ -131,70 +135,104 @@ export class NotificationService implements INotificationService {
     toUserId: string,
     type: NotificationTypes,
     data: Record<string, unknown>,
-  ): Promise<boolean> {
-    try {
-      const { error } = await supabase.from('notifications').insert({
-        user_id: toUserId,
-        type,
-        title: this.generateTitle(type, data),
-        message: this.generateMessage(type, data),
-        data,
-        priority: this.getPriority(type),
-      });
-
-      if (error) {
-        SecureLogger.error('Failed to send notification', {
-          code: 'NOTIF_001',
-          context: error.message,
+  ): Promise<Result<boolean>> {
+    return this.wrapAsync(
+      'sendNotification',
+      async () => {
+        const { error } = await supabase.from('notifications').insert({
+          user_id: toUserId,
+          type,
+          title: this.generateTitle(type, data),
+          message: this.generateMessage(type, data),
+          data,
+          priority: this.getPriority(type),
         });
-        return false;
-      }
 
-      return true;
-    } catch (error) {
-      SecureLogger.error('Failed to send notification', {
-        code: 'NOTIF_002',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+        if (error) throw error;
+        return true;
+      },
+      { toUserId, type, hasData: Object.keys(data).length > 0 },
+    );
   }
 
-  async notifyTaskAssigned(task: Task, assignedByUser: User): Promise<boolean> {
-    if (!task.assignedTo) return false;
-
-    return this.sendNotification(task.assignedTo, NOTIFICATION_TYPES.TASK_ASSIGNED, {
-      taskId: task.id,
-      taskTitle: task.title,
-      assignedByUserId: assignedByUser.id,
-      fromUserName: assignedByUser.name,
-    });
+  async notifyTaskAssigned(task: Task, assignedByUser: User): Promise<Result<boolean>> {
+    return this.wrapAsync(
+      'notifyTaskAssigned',
+      async () => {
+        if (!task.assignedTo) {
+          return false;
+        }
+
+        const result = await this.sendNotification(
+          task.assignedTo,
+          NOTIFICATION_TYPES.TASK_ASSIGNED,
+          {
+            taskId: task.id,
+            taskTitle: task.title,
+            assignedByUserId: assignedByUser.id,
+            fromUserName: assignedByUser.name,
+          },
+        );
+
+        return result.success ? result.data! : false;
+      },
+      { taskId: task.id, assignedTo: task.assignedTo, assignedBy: assignedByUser.id },
+    );
   }
 
-  async notifyTaskStarted(task: Task, startedByUser: User): Promise<boolean> {
-    if (!task.assignedBy || task.assignedBy === startedByUser.id) return true;
-
-    return this.sendNotification(task.assignedBy, NOTIFICATION_TYPES.TASK_STARTED, {
-      taskId: task.id,
-      taskTitle: task.title,
-      startedByUserId: startedByUser.id,
-      fromUserName: startedByUser.name,
-    });
+  async notifyTaskStarted(task: Task, startedByUser: User): Promise<Result<boolean>> {
+    return this.wrapAsync(
+      'notifyTaskStarted',
+      async () => {
+        if (!task.assignedBy || task.assignedBy === startedByUser.id) {
+          return true;
+        }
+
+        const result = await this.sendNotification(
+          task.assignedBy,
+          NOTIFICATION_TYPES.TASK_STARTED,
+          {
+            taskId: task.id,
+            taskTitle: task.title,
+            startedByUserId: startedByUser.id,
+            fromUserName: startedByUser.name,
+          },
+        );
+
+        return result.success ? result.data! : false;
+      },
+      { taskId: task.id, assignedBy: task.assignedBy, startedBy: startedByUser.id },
+    );
   }
 
-  async notifyTaskCompleted(task: Task, completedByUser: User): Promise<boolean> {
-    if (!task.assignedBy || task.assignedBy === completedByUser.id) return true;
-
-    return this.sendNotification(task.assignedBy, NOTIFICATION_TYPES.TASK_COMPLETED, {
-      taskId: task.id,
-      taskTitle: task.title,
-      completedByUserId: completedByUser.id,
-      fromUserName: completedByUser.name,
-      xpEarned: task.xpEarned,
-    });
+  async notifyTaskCompleted(task: Task, completedByUser: User): Promise<Result<boolean>> {
+    return this.wrapAsync(
+      'notifyTaskCompleted',
+      async () => {
+        if (!task.assignedBy || task.assignedBy === completedByUser.id) {
+          return true;
+        }
+
+        const result = await this.sendNotification(
+          task.assignedBy,
+          NOTIFICATION_TYPES.TASK_COMPLETED,
+          {
+            taskId: task.id,
+            taskTitle: task.title,
+            completedByUserId: completedByUser.id,
+            fromUserName: completedByUser.name,
+            xpEarned: task.xpEarned,
+          },
+        );
+
+        return result.success ? result.data! : false;
+      },
+      { taskId: task.id, assignedBy: task.assignedBy, completedBy: completedByUser.id },
+    );
   }
 
-  async notifyTaskOverdue(task: Task): Promise<boolean> {
+  async notifyTaskOverdue(task: Task): Promise<Result<boolean>> {
+    // Calculate userIds upfront for context
     const userIds: string[] = [];
 
     // Notify the task owner
@@ -212,17 +250,23 @@ export class NotificationService implements INotificationService {
       userIds.push(task.assignedBy);
     }
 
-    const results = await Promise.all(
-      userIds.map((userId) =>
-        this.sendNotification(userId, NOTIFICATION_TYPES.TASK_OVERDUE, {
-          taskId: task.id,
-          taskTitle: task.title,
-          dueDate: task.dueDate?.toISOString(),
-        }),
-      ),
+    return this.wrapAsync(
+      'notifyTaskOverdue',
+      async () => {
+        const results = await Promise.all(
+          userIds.map((userId) =>
+            this.sendNotification(userId, NOTIFICATION_TYPES.TASK_OVERDUE, {
+              taskId: task.id,
+              taskTitle: task.title,
+              dueDate: task.dueDate?.toISOString(),
+            }),
+          ),
+        );
+
+        return results.every((result) => result.success && result.data);
+      },
+      { taskId: task.id, userIds, dueDate: task.dueDate?.toISOString() },
     );
-
-    return results.every((result) => result);
   }
 
   async sendEncouragement(
@@ -230,159 +274,138 @@ export class NotificationService implements INotificationService {
     toUserId: string,
     message: string,
     taskId?: string | null,
-  ): Promise<boolean> {
-    const fromUser = await UserStorageService.getUserById(fromUserId);
-    if (!fromUser) return false;
-
-    return this.sendNotification(toUserId, NOTIFICATION_TYPES.ENCOURAGEMENT, {
-      fromUserId,
-      fromUserName: fromUser.name,
-      message,
-      taskId,
-    });
-  }
-
-  async sendCheckIn(fromUserId: string, toUserId: string, message: string): Promise<boolean> {
-    const fromUser = await UserStorageService.getUserById(fromUserId);
-    if (!fromUser) return false;
-
-    return this.sendNotification(toUserId, NOTIFICATION_TYPES.CHECK_IN, {
-      fromUserId,
-      fromUserName: fromUser.name,
-      message,
-    });
-  }
-
-  async getNotificationsForUser(userId: string): Promise<Notification[]> {
-    try {
-      const { data, error } = await supabase
-        .from('notifications')
-        .select('*')
-        .eq('user_id', userId)
-        .order('created_at', { ascending: false })
-        .limit(100);
-
-      if (error) {
-        SecureLogger.error('Failed to fetch notifications', {
-          code: 'NOTIF_003',
-          context: error.message,
+  ): Promise<Result<boolean>> {
+    return this.wrapAsync(
+      'sendEncouragement',
+      async () => {
+        const fromUser = await UserStorageService.getUserById(fromUserId);
+        if (!fromUser) {
+          return false;
+        }
+        const result = await this.sendNotification(toUserId, NOTIFICATION_TYPES.ENCOURAGEMENT, {
+          fromUserId,
+          fromUserName: fromUser.name ?? 'Unknown User',
+          message,
+          taskId,
         });
-        return [];
-      }
 
-      return (data || []).map(this.transformDbNotificationToNotification);
-    } catch (error) {
-      SecureLogger.error('Failed to get notifications', {
-        code: 'NOTIF_004',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return [];
-    }
+        return result.success ? result.data! : false;
+      },
+      { fromUserId, toUserId, taskId },
+    );
   }
 
-  async getUnreadNotificationCount(userId: string): Promise<number> {
-    try {
-      const { data, error } = await supabase
-        .from('notifications')
-        .select('id')
-        .eq('user_id', userId)
-        .is('read', false);
-
-      if (error) {
-        SecureLogger.error('Failed to count unread notifications', {
-          code: 'NOTIF_005',
-          context: error.message,
+  async sendCheckIn(
+    fromUserId: string,
+    toUserId: string,
+    message: string,
+  ): Promise<Result<boolean>> {
+    return this.wrapAsync(
+      'sendCheckIn',
+      async () => {
+        const fromUser = await UserStorageService.getUserById(fromUserId);
+        if (!fromUser) {
+          return false;
+        }
+        const result = await this.sendNotification(toUserId, NOTIFICATION_TYPES.CHECK_IN, {
+          fromUserId,
+          fromUserName: fromUser.name ?? 'Unknown User',
+          message,
         });
-        return 0;
-      }
 
-      return data?.length ?? 0;
-    } catch (error) {
-      SecureLogger.error('Failed to get unread count', {
-        code: 'NOTIF_006',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return 0;
-    }
+        return result.success ? result.data! : false;
+      },
+      { fromUserId, toUserId },
+    );
   }
 
-  async markNotificationAsRead(notificationId: string): Promise<boolean> {
-    try {
-      const { error } = await supabase
-        .from('notifications')
-        .update({
-          read: true,
-          read_at: new Date().toISOString(),
-        })
-        .eq('id', notificationId);
-
-      if (error) {
-        SecureLogger.error('Failed to mark notification as read', {
-          code: 'NOTIF_007',
-          context: error.message,
-        });
-        return false;
-      }
-
-      return true;
-    } catch (error) {
-      SecureLogger.error('Failed to mark as read', {
-        code: 'NOTIF_008',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+  async getNotificationsForUser(userId: string): Promise<Result<Notification[]>> {
+    return this.wrapAsync(
+      'getNotificationsForUser',
+      async () => {
+        const { data, error } = await supabase
+          .from('notifications')
+          .select('*')
+          .eq('user_id', userId)
+          .order('created_at', { ascending: false })
+          .limit(100);
+
+        if (error) throw error;
+
+        return (data || []).map(this.transformDbNotificationToNotification);
+      },
+      { userId },
+    );
   }
 
-  async markAllNotificationsAsRead(userId: string): Promise<boolean> {
-    try {
-      const { error } = await supabase
-        .from('notifications')
-        .update({
-          read: true,
-          read_at: new Date().toISOString(),
-        })
-        .eq('user_id', userId)
-        .is('read', false);
-
-      if (error) {
-        SecureLogger.error('Failed to mark all notifications as read', {
-          code: 'NOTIF_009',
-          context: error.message,
-        });
-        return false;
-      }
+  async getUnreadNotificationCount(userId: string): Promise<Result<number>> {
+    return this.wrapAsync(
+      'getUnreadNotificationCount',
+      async () => {
+        const { data, error } = await supabase
+          .from('notifications')
+          .select('id')
+          .eq('user_id', userId)
+          .is('read', false);
+
+        if (error) throw error;
+
+        return data?.length ?? 0;
+      },
+      { userId },
+    );
+  }
 
-      return true;
-    } catch (error) {
-      SecureLogger.error('Failed to mark all as read', {
-        code: 'NOTIF_010',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+  async markNotificationAsRead(notificationId: string): Promise<Result<boolean>> {
+    return this.wrapAsync(
+      'markNotificationAsRead',
+      async () => {
+        const { error } = await supabase
+          .from('notifications')
+          .update({
+            read: true,
+            read_at: new Date().toISOString(),
+          })
+          .eq('id', notificationId);
+
+        if (error) throw error;
+        return true;
+      },
+      { notificationId },
+    );
   }
 
-  async clearNotificationsForUser(userId: string): Promise<boolean> {
-    try {
-      const { error } = await supabase.from('notifications').delete().eq('user_id', userId);
+  async markAllNotificationsAsRead(userId: string): Promise<Result<boolean>> {
+    return this.wrapAsync(
+      'markAllNotificationsAsRead',
+      async () => {
+        const { error } = await supabase
+          .from('notifications')
+          .update({
+            read: true,
+            read_at: new Date().toISOString(),
+          })
+          .eq('user_id', userId)
+          .is('read', false);
+
+        if (error) throw error;
+        return true;
+      },
+      { userId },
+    );
+  }
 
-      if (error) {
-        SecureLogger.error('Failed to clear notifications', {
-          code: 'NOTIF_011',
-          context: error.message,
-        });
-        return false;
-      }
+  async clearNotificationsForUser(userId: string): Promise<Result<boolean>> {
+    return this.wrapAsync(
+      'clearNotificationsForUser',
+      async () => {
+        const { error } = await supabase.from('notifications').delete().eq('user_id', userId);
 
-      return true;
-    } catch (error) {
-      SecureLogger.error('Failed to clear notifications', {
-        code: 'NOTIF_012',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+        if (error) throw error;
+        return true;
+      },
+      { userId },
+    );
   }
 
   subscribeToNotifications(
diff --git a/src/services/PartnershipService.ts b/src/services/PartnershipService.ts
index 2e0372f..507e82a 100644
--- a/src/services/PartnershipService.ts
+++ b/src/services/PartnershipService.ts
@@ -3,8 +3,9 @@
 
 import type { RealtimeChannel } from '@supabase/supabase-js';
 import { supabase } from './SupabaseService';
+import { BaseService } from './BaseService';
 import UserStorageService from './UserStorageService';
-import type { Partnership, PartnershipStats, PartnershipSettings } from '../types';
+import type { Partnership, PartnershipStats, PartnershipSettings, Result } from '../types';
 import { PartnershipStatus } from '../types';
 import { createPartnership, acceptPartnership } from '../utils/PartnershipModel';
 import { setUserPartner } from '../utils/UserModel';
@@ -26,37 +27,41 @@ interface DatabasePartnership {
 }
 
 export interface IPartnershipService {
-  getAllPartnerships(): Promise<Partnership[]>;
-  savePartnership(partnership: Partnership): Promise<boolean>;
-  updatePartnership(updatedPartnership: Partnership): Promise<boolean>;
+  getAllPartnerships(): Promise<Result<Partnership[]>>;
+  savePartnership(partnership: Partnership): Promise<Result<boolean>>;
+  updatePartnership(updatedPartnership: Partnership): Promise<Result<boolean>>;
   createPartnershipInvite(
     invitingUserId: string,
     invitedUserRole: string,
-  ): Promise<Partnership | null>;
+  ): Promise<Result<Partnership>>;
   acceptPartnershipInvite(
     inviteCode: string,
     acceptingUserId: string,
-  ): Promise<{ success: boolean; error?: string; partnership?: Partnership }>;
-  getPartnershipByUsers(userId1: string, userId2: string): Promise<Partnership | null>;
-  getPartnershipByInviteCode(inviteCode: string): Promise<Partnership | null>;
-  getUserPartnerships(userId: string): Promise<Partnership[]>;
-  getActivePartnership(userId: string): Promise<Partnership | null>;
+  ): Promise<Result<Partnership>>;
+  getPartnershipByUsers(userId1: string, userId2: string): Promise<Result<Partnership | null>>;
+  getPartnershipByInviteCode(inviteCode: string): Promise<Result<Partnership | null>>;
+  getUserPartnerships(userId: string): Promise<Result<Partnership[]>>;
+  getActivePartnership(userId: string): Promise<Result<Partnership | null>>;
   incrementPartnershipStat(
     partnershipId: string,
     statKey: keyof PartnershipStats,
     increment?: number,
-  ): Promise<boolean>;
-  clearAllPartnerships(): Promise<boolean>;
+  ): Promise<Result<boolean>>;
+  clearAllPartnerships(): Promise<Result<boolean>>;
   subscribeToPartnershipUpdates(
     userId: string,
     callback: (partnership: Partnership, action: 'INSERT' | 'UPDATE' | 'DELETE') => void,
   ): RealtimeChannel;
 }
 
-class SupabasePartnershipService implements IPartnershipService {
+class SupabasePartnershipService extends BaseService implements IPartnershipService {
   private cache = new Map<string, { data: Partnership[]; timestamp: number }>();
   private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
 
+  constructor() {
+    super('Partnership');
+  }
+
   private getCacheKey(key: string): string {
     return `partnerships_${key}`;
   }
@@ -90,270 +95,307 @@ class SupabasePartnershipService implements IPartnershipService {
     }
   }
 
-  async getAllPartnerships(): Promise<Partnership[]> {
-    try {
-      return await this.getCachedOrFetch(this.getCacheKey('all'), async () => {
-        const { data, error } = await supabase.from('partnerships').select('*');
-
-        if (error) throw error;
-        return this.transformDatabasePartnerships((data ?? []) as DatabasePartnership[]);
-      });
-    } catch (error) {
-      console.error('Error fetching partnerships:', error);
-      return [];
-    }
+  async getAllPartnerships(): Promise<Result<Partnership[]>> {
+    return this.wrapAsync(
+      'getAllPartnerships',
+      async () => {
+        return this.getCachedOrFetch(this.getCacheKey('all'), async () => {
+          const { data, error } = await supabase.from('partnerships').select('*');
+
+          if (error) throw error;
+          return this.transformDatabasePartnerships((data ?? []) as DatabasePartnership[]);
+        });
+      },
+      { operation: 'fetch_all_partnerships' },
+    );
   }
 
-  async savePartnership(partnership: Partnership): Promise<boolean> {
-    try {
-      const dbPartnership = this.transformToDatabase(partnership);
+  async savePartnership(partnership: Partnership): Promise<Result<boolean>> {
+    return this.wrapAsync(
+      'savePartnership',
+      async () => {
+        const dbPartnership = this.transformToDatabase(partnership);
 
-      const { error } = await supabase.from('partnerships').insert([dbPartnership]);
+        const { error } = await supabase.from('partnerships').insert([dbPartnership]);
 
-      if (error) throw error;
+        if (error) throw error;
 
-      this.invalidateCache();
-      return true;
-    } catch (error) {
-      console.error('Error saving partnership:', error);
-      return false;
-    }
+        this.invalidateCache();
+        return true;
+      },
+      { partnership_id: partnership.id, operation: 'save_partnership' },
+    );
   }
 
-  async updatePartnership(updatedPartnership: Partnership): Promise<boolean> {
-    try {
-      const dbPartnership = this.transformToDatabase(updatedPartnership);
+  async updatePartnership(updatedPartnership: Partnership): Promise<Result<boolean>> {
+    return this.wrapAsync(
+      'updatePartnership',
+      async () => {
+        const dbPartnership = this.transformToDatabase(updatedPartnership);
 
-      const { error } = await supabase
-        .from('partnerships')
-        .update(dbPartnership)
-        .eq('id', updatedPartnership.id);
+        const { error } = await supabase
+          .from('partnerships')
+          .update(dbPartnership)
+          .eq('id', updatedPartnership.id);
 
-      if (error) throw error;
+        if (error) throw error;
 
-      this.invalidateCache();
-      return true;
-    } catch (error) {
-      console.error('Error updating partnership:', error);
-      return false;
-    }
+        this.invalidateCache();
+        return true;
+      },
+      { partnership_id: updatedPartnership.id, operation: 'update_partnership' },
+    );
   }
 
   async createPartnershipInvite(
     invitingUserId: string,
     invitedUserRole: string,
-  ): Promise<Partnership | null> {
-    try {
-      // Generate unique invite code
-      const result = await supabase.rpc('generate_invite_code');
+  ): Promise<Result<Partnership>> {
+    return this.wrapAsync(
+      'createPartnershipInvite',
+      async () => {
+        // Generate unique invite code
+        const result = await supabase.rpc('generate_invite_code');
 
-      if (result.error) throw result.error;
+        if (result.error) throw result.error;
 
-      const inviteCode = result.data as string;
+        const inviteCode = result.data as string;
 
-      const partnership = createPartnership({
-        inviteSentBy: invitingUserId,
-        adhdUserId: invitedUserRole === 'partner' ? invitingUserId : null,
-        partnerId: invitedUserRole === 'adhd_user' ? invitingUserId : null,
-        inviteCode: inviteCode,
-      });
+        const partnership = createPartnership({
+          inviteSentBy: invitingUserId,
+          adhdUserId: invitedUserRole === 'partner' ? invitingUserId : null,
+          partnerId: invitedUserRole === 'adhd_user' ? invitingUserId : null,
+          inviteCode: inviteCode,
+        });
 
-      const dbPartnership = this.transformToDatabase(partnership);
+        const dbPartnership = this.transformToDatabase(partnership);
 
-      const { data, error } = await supabase
-        .from('partnerships')
-        .insert([dbPartnership])
-        .select()
-        .single<DatabasePartnership>();
+        const { data, error } = await supabase
+          .from('partnerships')
+          .insert([dbPartnership])
+          .select()
+          .single<DatabasePartnership>();
 
-      if (error) throw error;
+        if (error) throw error;
 
-      this.invalidateCache();
-      return this.transformDatabasePartnership(data);
-    } catch (error) {
-      console.error('Error creating partnership invite:', error);
-      return null;
-    }
+        this.invalidateCache();
+        return this.transformDatabasePartnership(data);
+      },
+      {
+        inviting_user_id: invitingUserId,
+        invited_user_role: invitedUserRole,
+        operation: 'create_partnership_invite',
+      },
+    );
   }
 
   async acceptPartnershipInvite(
     inviteCode: string,
     acceptingUserId: string,
-  ): Promise<{ success: boolean; error?: string; partnership?: Partnership }> {
-    try {
-      // Find the partnership by invite code
-      const { data: partnershipData, error: findError } = await supabase
-        .from('partnerships')
-        .select('*')
-        .eq('invite_code', inviteCode)
-        .single<DatabasePartnership>();
-
-      if (findError || !partnershipData) {
-        return { success: false, error: 'Invalid invite code' };
-      }
+  ): Promise<Result<Partnership>> {
+    return this.wrapAsync(
+      'acceptPartnershipInvite',
+      async () => {
+        // Find the partnership by invite code
+        const { data: partnershipData, error: findError } = await supabase
+          .from('partnerships')
+          .select('*')
+          .eq('invite_code', inviteCode)
+          .single<DatabasePartnership>();
 
-      const partnership = this.transformDatabasePartnership(partnershipData);
+        if (findError || !partnershipData) {
+          throw new Error('Invalid invite code');
+        }
 
-      if (partnership.status !== PartnershipStatus.PENDING) {
-        return { success: false, error: 'Invite already used' };
-      }
+        const partnership = this.transformDatabasePartnership(partnershipData);
 
-      // Set the accepting user in the appropriate role
-      if (!partnership.adhdUserId) {
-        partnership.adhdUserId = acceptingUserId;
-      } else if (!partnership.partnerId) {
-        partnership.partnerId = acceptingUserId;
-      } else {
-        return { success: false, error: 'Partnership already complete' };
-      }
+        if (partnership.status !== PartnershipStatus.PENDING) {
+          throw new Error('Invite already used');
+        }
 
-      const acceptedPartnership = acceptPartnership(partnership);
-      const dbPartnership = this.transformToDatabase(acceptedPartnership);
+        // Set the accepting user in the appropriate role
+        if (!partnership.adhdUserId) {
+          partnership.adhdUserId = acceptingUserId;
+        } else if (!partnership.partnerId) {
+          partnership.partnerId = acceptingUserId;
+        } else {
+          throw new Error('Partnership already complete');
+        }
 
-      const { data: updatedData, error: updateError } = await supabase
-        .from('partnerships')
-        .update(dbPartnership)
-        .eq('id', partnership.id)
-        .select()
-        .single<DatabasePartnership>();
+        const acceptedPartnership = acceptPartnership(partnership);
+        const dbPartnership = this.transformToDatabase(acceptedPartnership);
 
-      if (updateError) throw updateError;
+        const { data: updatedData, error: updateError } = await supabase
+          .from('partnerships')
+          .update(dbPartnership)
+          .eq('id', partnership.id)
+          .select()
+          .single<DatabasePartnership>();
 
-      // Update both users with partner IDs
-      if (acceptedPartnership.adhdUserId && acceptedPartnership.partnerId) {
-        const adhdUser = await UserStorageService.getUserById(acceptedPartnership.adhdUserId);
-        const partner = await UserStorageService.getUserById(acceptedPartnership.partnerId);
+        if (updateError) throw updateError;
 
-        if (adhdUser) {
-          const updatedAdhdUser = setUserPartner(adhdUser, acceptedPartnership.partnerId);
-          await UserStorageService.updateUser(updatedAdhdUser);
-        }
+        // Update both users with partner IDs
+        if (acceptedPartnership.adhdUserId && acceptedPartnership.partnerId) {
+          const adhdUser = await UserStorageService.getUserById(acceptedPartnership.adhdUserId);
+          const partner = await UserStorageService.getUserById(acceptedPartnership.partnerId);
 
-        if (partner) {
-          const updatedPartner = setUserPartner(partner, acceptedPartnership.adhdUserId);
-          await UserStorageService.updateUser(updatedPartner);
-        }
-      }
+          if (adhdUser) {
+            const updatedAdhdUser = setUserPartner(adhdUser, acceptedPartnership.partnerId);
+            await UserStorageService.updateUser(updatedAdhdUser);
+          }
 
-      this.invalidateCache();
-      return {
-        success: true,
-        partnership: this.transformDatabasePartnership(updatedData),
-      };
-    } catch (error) {
-      console.error('Error accepting partnership invite:', error);
-      return { success: false, error: 'Failed to accept invite' };
-    }
-  }
+          if (partner) {
+            const updatedPartner = setUserPartner(partner, acceptedPartnership.adhdUserId);
+            await UserStorageService.updateUser(updatedPartner);
+          }
+        }
 
-  async getPartnershipByUsers(userId1: string, userId2: string): Promise<Partnership | null> {
-    try {
-      const { data, error } = await supabase
-        .from('partnerships')
-        .select('*')
-        .or(
-          `and(adhd_user_id.eq.${userId1},partner_id.eq.${userId2}),and(adhd_user_id.eq.${userId2},partner_id.eq.${userId1})`,
-        )
-        .single<DatabasePartnership>();
-
-      if (error || !data) return null;
-
-      return this.transformDatabasePartnership(data);
-    } catch (error) {
-      console.error('Error getting partnership by users:', error);
-      return null;
-    }
+        this.invalidateCache();
+        return this.transformDatabasePartnership(updatedData);
+      },
+      {
+        invite_code: inviteCode,
+        accepting_user_id: acceptingUserId,
+        operation: 'accept_partnership_invite',
+      },
+    );
   }
 
-  async getPartnershipByInviteCode(inviteCode: string): Promise<Partnership | null> {
-    try {
-      const { data, error } = await supabase
-        .from('partnerships')
-        .select('*')
-        .eq('invite_code', inviteCode)
-        .single<DatabasePartnership>();
-
-      if (error || !data) return null;
-
-      return this.transformDatabasePartnership(data);
-    } catch (error) {
-      console.error('Error getting partnership by invite code:', error);
-      return null;
-    }
+  async getPartnershipByUsers(
+    userId1: string,
+    userId2: string,
+  ): Promise<Result<Partnership | null>> {
+    return this.wrapAsync(
+      'getPartnershipByUsers',
+      async () => {
+        const { data, error } = await supabase
+          .from('partnerships')
+          .select('*')
+          .or(
+            `and(adhd_user_id.eq.${userId1},partner_id.eq.${userId2}),and(adhd_user_id.eq.${userId2},partner_id.eq.${userId1})`,
+          )
+          .single<DatabasePartnership>();
+
+        if (error || !data) return null;
+
+        return this.transformDatabasePartnership(data);
+      },
+      {
+        user_id_1: userId1,
+        user_id_2: userId2,
+        operation: 'get_partnership_by_users',
+      },
+    );
   }
 
-  async getUserPartnerships(userId: string): Promise<Partnership[]> {
-    try {
-      return await this.getCachedOrFetch(this.getCacheKey(`user_${userId}`), async () => {
+  async getPartnershipByInviteCode(inviteCode: string): Promise<Result<Partnership | null>> {
+    return this.wrapAsync(
+      'getPartnershipByInviteCode',
+      async () => {
         const { data, error } = await supabase
           .from('partnerships')
           .select('*')
-          .or(`adhd_user_id.eq.${userId},partner_id.eq.${userId}`);
+          .eq('invite_code', inviteCode)
+          .single<DatabasePartnership>();
+
+        if (error || !data) return null;
+
+        return this.transformDatabasePartnership(data);
+      },
+      {
+        invite_code: inviteCode,
+        operation: 'get_partnership_by_invite_code',
+      },
+    );
+  }
 
-        if (error) throw error;
-        return this.transformDatabasePartnerships((data ?? []) as DatabasePartnership[]);
-      });
-    } catch (error) {
-      console.error('Error getting user partnerships:', error);
-      return [];
-    }
+  async getUserPartnerships(userId: string): Promise<Result<Partnership[]>> {
+    return this.wrapAsync(
+      'getUserPartnerships',
+      async () => {
+        return this.getCachedOrFetch(this.getCacheKey(`user_${userId}`), async () => {
+          const { data, error } = await supabase
+            .from('partnerships')
+            .select('*')
+            .or(`adhd_user_id.eq.${userId},partner_id.eq.${userId}`);
+
+          if (error) throw error;
+          return this.transformDatabasePartnerships((data ?? []) as DatabasePartnership[]);
+        });
+      },
+      {
+        user_id: userId,
+        operation: 'get_user_partnerships',
+      },
+    );
   }
 
-  async getActivePartnership(userId: string): Promise<Partnership | null> {
-    try {
-      const { data, error } = await supabase
-        .from('partnerships')
-        .select('*')
-        .or(`adhd_user_id.eq.${userId},partner_id.eq.${userId}`)
-        .eq('status', 'active')
-        .single<DatabasePartnership>();
-
-      if (error || !data) return null;
-
-      return this.transformDatabasePartnership(data);
-    } catch (error) {
-      console.error('Error getting active partnership:', error);
-      return null;
-    }
+  async getActivePartnership(userId: string): Promise<Result<Partnership | null>> {
+    return this.wrapAsync(
+      'getActivePartnership',
+      async () => {
+        const { data, error } = await supabase
+          .from('partnerships')
+          .select('*')
+          .or(`adhd_user_id.eq.${userId},partner_id.eq.${userId}`)
+          .eq('status', 'active')
+          .single<DatabasePartnership>();
+
+        if (error || !data) return null;
+
+        return this.transformDatabasePartnership(data);
+      },
+      {
+        user_id: userId,
+        operation: 'get_active_partnership',
+      },
+    );
   }
 
   async incrementPartnershipStat(
     partnershipId: string,
     statKey: keyof PartnershipStats,
     increment: number = 1,
-  ): Promise<boolean> {
-    try {
-      const { error } = await supabase.rpc('update_partnership_stats', {
-        partnership_id: partnershipId,
-        stat_key: statKey,
-        increment: increment,
-      });
+  ): Promise<Result<boolean>> {
+    return this.wrapAsync(
+      'incrementPartnershipStat',
+      async () => {
+        const { error } = await supabase.rpc('update_partnership_stats', {
+          partnership_id: partnershipId,
+          stat_key: statKey,
+          increment: increment,
+        });
 
-      if (error) throw error;
+        if (error) throw error;
 
-      this.invalidateCache();
-      return true;
-    } catch (error) {
-      console.error('Error incrementing partnership stat:', error);
-      return false;
-    }
+        this.invalidateCache();
+        return true;
+      },
+      {
+        partnership_id: partnershipId,
+        stat_key: statKey,
+        increment,
+        operation: 'increment_partnership_stat',
+      },
+    );
   }
 
-  async clearAllPartnerships(): Promise<boolean> {
-    try {
-      const { error } = await supabase
-        .from('partnerships')
-        .delete()
-        .neq('id', '00000000-0000-0000-0000-000000000000'); // Delete all
+  async clearAllPartnerships(): Promise<Result<boolean>> {
+    return this.wrapAsync(
+      'clearAllPartnerships',
+      async () => {
+        const { error } = await supabase
+          .from('partnerships')
+          .delete()
+          .neq('id', '00000000-0000-0000-0000-000000000000'); // Delete all
 
-      if (error) throw error;
+        if (error) throw error;
 
-      this.invalidateCache();
-      return true;
-    } catch (error) {
-      console.error('Error clearing partnerships:', error);
-      return false;
-    }
+        this.invalidateCache();
+        return true;
+      },
+      { operation: 'clear_all_partnerships' },
+    );
   }
 
   subscribeToPartnershipUpdates(
@@ -431,4 +473,5 @@ class SupabasePartnershipService implements IPartnershipService {
   }
 }
 
+export { SupabasePartnershipService };
 export default new SupabasePartnershipService();
diff --git a/src/services/SecureStorageService.ts b/src/services/SecureStorageService.ts
index ecf86d0..6279c57 100644
--- a/src/services/SecureStorageService.ts
+++ b/src/services/SecureStorageService.ts
@@ -2,7 +2,7 @@
 // for sensitive data like user profiles, tokens, and tasks
 
 import * as SecureStore from 'expo-secure-store';
-import SecureLogger from './SecureLogger';
+import { BaseService } from './BaseService';
 
 export interface ISecureStorageService {
   setItem(key: string, value: unknown): Promise<void>;
@@ -19,10 +19,14 @@ export interface ISecureStorageService {
   deleteSecure(key: string): Promise<void>;
 }
 
-class SecureStorageService implements ISecureStorageService {
+class SecureStorageService extends BaseService implements ISecureStorageService {
   // expo-secure-store has a 2KB size limit per item
   static readonly MAX_VALUE_SIZE = 2048;
 
+  constructor() {
+    super('SecureStorageService');
+  }
+
   private validateKey(key: string): void {
     if (typeof key !== 'string' || key.length === 0) {
       throw new Error('Storage key must be a non-empty string');
@@ -30,148 +34,236 @@ class SecureStorageService implements ISecureStorageService {
   }
 
   async setItem(key: string, value: unknown): Promise<void> {
-    this.validateKey(key);
-    const stringValue = typeof value === 'string' ? value : JSON.stringify(value);
-
-    // Check size limit
-    if (stringValue.length > SecureStorageService.MAX_VALUE_SIZE) {
-      throw new Error(
-        `Value size exceeds the maximum limit of ${SecureStorageService.MAX_VALUE_SIZE} bytes`,
-      );
-    }
+    const result = await this.wrapAsync(
+      'setItem',
+      async () => {
+        this.validateKey(key);
+        const stringValue = typeof value === 'string' ? value : JSON.stringify(value);
+
+        // Check size limit
+        if (stringValue.length > SecureStorageService.MAX_VALUE_SIZE) {
+          throw new Error(
+            `Value size exceeds the maximum limit of ${SecureStorageService.MAX_VALUE_SIZE} bytes`,
+          );
+        }
 
-    await SecureStore.setItemAsync(key, stringValue);
+        await SecureStore.setItemAsync(key, stringValue);
+      },
+      { key, valueSize: typeof value === 'string' ? value.length : JSON.stringify(value).length },
+    );
+
+    if (!result.success) {
+      throw new Error(result.error!.message);
+    }
   }
 
   async getItem<T = unknown>(key: string): Promise<T | null> {
-    this.validateKey(key);
-    const value = await SecureStore.getItemAsync(key);
-    if (value === null) {
-      return null;
-    }
+    const result = await this.wrapAsync(
+      'getItem',
+      async () => {
+        this.validateKey(key);
+        const value = await SecureStore.getItemAsync(key);
+        if (value === null) {
+          return null;
+        }
+
+        // Try to parse as JSON, if it fails return as string
+        try {
+          return JSON.parse(value) as T;
+        } catch {
+          return value as T;
+        }
+      },
+      { key },
+    );
 
-    // Try to parse as JSON, if it fails return as string
-    try {
-      return JSON.parse(value) as T;
-    } catch {
-      return value as T;
+    if (!result.success) {
+      throw new Error(result.error!.message);
     }
+
+    return result.data!;
   }
 
   async removeItem(key: string): Promise<void> {
-    this.validateKey(key);
-    await SecureStore.deleteItemAsync(key);
+    const result = await this.wrapAsync(
+      'removeItem',
+      async () => {
+        this.validateKey(key);
+        await SecureStore.deleteItemAsync(key);
+      },
+      { key },
+    );
+
+    if (!result.success) {
+      throw new Error(result.error!.message);
+    }
   }
 
   getAllKeys(): Promise<string[]> {
     // SecureStore does not support getting all keys
     // Return empty array for compatibility
-    return Promise.resolve([]);
+    const result = this.wrapSync('getAllKeys', () => []);
+
+    if (!result.success) {
+      throw new Error(result.error!.message);
+    }
+
+    return Promise.resolve(result.data!);
   }
 
   clear(): Promise<void> {
     // SecureStore does not support clearing all items
-    return Promise.reject(new Error('SecureStore does not support clearing all items'));
+    const result = this.wrapSync('clear', () => {
+      throw new Error('SecureStore does not support clearing all items');
+    });
+
+    if (!result.success) {
+      throw new Error(result.error!.message);
+    }
+
+    return Promise.resolve();
   }
 
   async multiGet<T = unknown>(keys: string[]): Promise<Array<[string, T | null]>> {
-    if (!Array.isArray(keys)) {
-      throw new Error('Keys must be an array');
-    }
+    const result = await this.wrapAsync(
+      'multiGet',
+      async () => {
+        if (!Array.isArray(keys)) {
+          throw new Error('Keys must be an array');
+        }
 
-    const promises = keys.map(async (key) => {
-      try {
-        const value = await this.getItem(key);
-        return [key, value] as [string, T | null];
-      } catch (error) {
-        SecureLogger.error('Failed to get item from secure storage', {
-          code: 'SECURE_STORE_GET_001',
+        const promises = keys.map(async (key) => {
+          try {
+            const value = await this.getItem<T>(key);
+            return [key, value] as [string, T | null];
+          } catch (error) {
+            this.logger.error('Failed to get item from secure storage', {
+              code: 'SECURE_STORE_GET_001',
+            });
+            return [key, null] as [string, T | null];
+          }
         });
-        return [key, null] as [string, T | null];
-      }
-    });
 
-    return Promise.all(promises);
+        return Promise.all(promises);
+      },
+      { keysCount: keys.length },
+    );
+
+    if (!result.success) {
+      throw new Error(result.error!.message);
+    }
+
+    return result.data!;
   }
 
   async multiSet(kvPairs: Array<[string, unknown]>): Promise<void> {
-    if (!Array.isArray(kvPairs)) {
-      throw new Error('Key-value pairs must be an array');
-    }
+    const result = await this.wrapAsync(
+      'multiSet',
+      async () => {
+        if (!Array.isArray(kvPairs)) {
+          throw new Error('Key-value pairs must be an array');
+        }
 
-    const promises = kvPairs.map(async ([key, value]) => {
-      try {
-        await this.setItem(key, value);
-        return { key, success: true };
-      } catch (error) {
-        SecureLogger.error('Failed to set item in secure storage', {
-          code: 'SECURE_STORE_SET_001',
+        const promises = kvPairs.map(async ([key, value]) => {
+          try {
+            await this.setItem(key, value);
+            return { key, success: true };
+          } catch (error) {
+            this.logger.error('Failed to set item in secure storage', {
+              code: 'SECURE_STORE_SET_001',
+            });
+            return {
+              key,
+              success: false,
+              error: error instanceof Error ? error.message : String(error),
+            };
+          }
         });
-        return {
-          key,
-          success: false,
-          error: error instanceof Error ? error.message : String(error),
-        };
-      }
-    });
 
-    const results = await Promise.all(promises);
-    const failures = results.filter((r) => !r.success);
+        const results = await Promise.all(promises);
+        const failures = results.filter((r) => !r.success);
+
+        if (failures.length > 0) {
+          this.logger.warn('Some items failed to save in secure storage', {
+            code: 'SECURE_STORE_MULTI_SET_001',
+          });
+        }
+      },
+      { pairsCount: kvPairs.length },
+    );
 
-    if (failures.length > 0) {
-      SecureLogger.warn('Some items failed to save in secure storage', {
-        code: 'SECURE_STORE_MULTI_SET_001',
-      });
+    if (!result.success) {
+      throw new Error(result.error!.message);
     }
   }
 
   async multiRemove(keys: string[]): Promise<void> {
-    if (!Array.isArray(keys)) {
-      throw new Error('Keys must be an array');
-    }
+    const result = await this.wrapAsync(
+      'multiRemove',
+      async () => {
+        if (!Array.isArray(keys)) {
+          throw new Error('Keys must be an array');
+        }
 
-    const promises = keys.map(async (key) => {
-      try {
-        await this.removeItem(key);
-        return { key, success: true };
-      } catch (error) {
-        SecureLogger.error('Failed to remove item from secure storage', {
-          code: 'SECURE_STORE_REMOVE_001',
+        const promises = keys.map(async (key) => {
+          try {
+            await this.removeItem(key);
+            return { key, success: true };
+          } catch (error) {
+            this.logger.error('Failed to remove item from secure storage', {
+              code: 'SECURE_STORE_REMOVE_001',
+            });
+            return {
+              key,
+              success: false,
+              error: error instanceof Error ? error.message : String(error),
+            };
+          }
         });
-        return {
-          key,
-          success: false,
-          error: error instanceof Error ? error.message : String(error),
-        };
-      }
-    });
 
-    const results = await Promise.all(promises);
-    const failures = results.filter((r) => !r.success);
+        const results = await Promise.all(promises);
+        const failures = results.filter((r) => !r.success);
 
-    if (failures.length > 0) {
-      SecureLogger.warn('Some items failed to remove from secure storage', {
-        code: 'SECURE_STORE_MULTI_REMOVE_001',
-      });
+        if (failures.length > 0) {
+          this.logger.warn('Some items failed to remove from secure storage', {
+            code: 'SECURE_STORE_MULTI_REMOVE_001',
+          });
+        }
+      },
+      { keysCount: keys.length },
+    );
+
+    if (!result.success) {
+      throw new Error(result.error!.message);
     }
   }
 
   async mergeItem(key: string, value: Record<string, unknown>): Promise<void> {
-    this.validateKey(key);
+    const result = await this.wrapAsync(
+      'mergeItem',
+      async () => {
+        this.validateKey(key);
 
-    if (typeof value !== 'object' || value === null || Array.isArray(value)) {
-      throw new Error('Value must be a non-null object for merging');
-    }
+        if (typeof value !== 'object' || value === null || Array.isArray(value)) {
+          throw new Error('Value must be a non-null object for merging');
+        }
+
+        const existing = await this.getItem<Record<string, unknown>>(key);
 
-    const existing = await this.getItem<Record<string, unknown>>(key);
+        if (existing === null || typeof existing !== 'object' || Array.isArray(existing)) {
+          // If no existing value or it's not an object, just set the new value
+          await this.setItem(key, value);
+        } else {
+          // Merge the objects
+          const merged = { ...existing, ...value };
+          await this.setItem(key, merged);
+        }
+      },
+      { key },
+    );
 
-    if (existing === null || typeof existing !== 'object' || Array.isArray(existing)) {
-      // If no existing value or it's not an object, just set the new value
-      await this.setItem(key, value);
-    } else {
-      // Merge the objects
-      const merged = { ...existing, ...value };
-      await this.setItem(key, merged);
+    if (!result.success) {
+      throw new Error(result.error!.message);
     }
   }
 
diff --git a/src/services/SettingsService.ts b/src/services/SettingsService.ts
index 086591d..e0a3146 100644
--- a/src/services/SettingsService.ts
+++ b/src/services/SettingsService.ts
@@ -2,6 +2,8 @@
 // Handles Pomodoro timer settings, notification preferences, and other app configurations
 
 import AsyncStorage from '@react-native-async-storage/async-storage';
+import { BaseService } from './BaseService';
+import type { Result } from '../types/common.types';
 
 export interface PomodoroSettings {
   workDuration: number; // in minutes (5-90)
@@ -41,11 +43,13 @@ const DEFAULT_SETTINGS: AppSettings = {
 
 const SETTINGS_KEY = '@adhd_todo_settings';
 
-class SettingsService {
+class SettingsService extends BaseService {
   private static instance: SettingsService;
   private settings: AppSettings = DEFAULT_SETTINGS;
 
-  private constructor() {}
+  private constructor() {
+    super('SettingsService');
+  }
 
   static getInstance(): SettingsService {
     if (!SettingsService.instance) {
@@ -54,31 +58,37 @@ class SettingsService {
     return SettingsService.instance;
   }
 
-  async loadSettings(): Promise<AppSettings> {
-    try {
-      const stored = await AsyncStorage.getItem(SETTINGS_KEY);
-      if (stored) {
-        this.settings = { ...DEFAULT_SETTINGS, ...(JSON.parse(stored) as Partial<AppSettings>) };
-      }
-      return this.settings;
-    } catch (error) {
-      console.error('Error loading settings:', error);
-      return DEFAULT_SETTINGS;
-    }
+  async loadSettings(): Promise<Result<AppSettings>> {
+    const result = await this.wrapAsync(
+      'loadSettings',
+      async () => {
+        const stored = await AsyncStorage.getItem(SETTINGS_KEY);
+        if (stored) {
+          this.settings = { ...DEFAULT_SETTINGS, ...(JSON.parse(stored) as Partial<AppSettings>) };
+        }
+        return this.settings;
+      },
+      { storageKey: SETTINGS_KEY },
+    );
+
+    return result;
   }
 
-  async saveSettings(settings: AppSettings): Promise<boolean> {
-    try {
-      this.settings = settings;
-      await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
-      return true;
-    } catch (error) {
-      console.error('Error saving settings:', error);
-      return false;
-    }
+  async saveSettings(settings: AppSettings): Promise<Result<boolean>> {
+    const result = await this.wrapAsync(
+      'saveSettings',
+      async () => {
+        this.settings = settings;
+        await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
+        return true;
+      },
+      { storageKey: SETTINGS_KEY },
+    );
+
+    return result;
   }
 
-  async updatePomodoroSettings(pomodoro: Partial<PomodoroSettings>): Promise<boolean> {
+  async updatePomodoroSettings(pomodoro: Partial<PomodoroSettings>): Promise<Result<boolean>> {
     const updated = {
       ...this.settings,
       pomodoro: {
@@ -92,7 +102,7 @@ class SettingsService {
   async updateSetting<K extends keyof AppSettings>(
     key: K,
     value: AppSettings[K],
-  ): Promise<boolean> {
+  ): Promise<Result<boolean>> {
     const updated = {
       ...this.settings,
       [key]: value,
@@ -108,10 +118,44 @@ class SettingsService {
     return this.settings.pomodoro;
   }
 
-  resetToDefaults(): Promise<boolean> {
+  resetToDefaults(): Promise<Result<boolean>> {
     return this.saveSettings(DEFAULT_SETTINGS);
   }
 
+  // Convenience methods for backward compatibility
+  // These methods provide fallback values for easier migration
+
+  async loadSettingsCompat(): Promise<AppSettings> {
+    const result = await this.loadSettings();
+    if (result.success && result.data) {
+      return result.data;
+    }
+    return DEFAULT_SETTINGS;
+  }
+
+  async saveSettingsCompat(settings: AppSettings): Promise<boolean> {
+    const result = await this.saveSettings(settings);
+    return result.success && result.data ? result.data : false;
+  }
+
+  async updatePomodoroSettingsCompat(pomodoro: Partial<PomodoroSettings>): Promise<boolean> {
+    const result = await this.updatePomodoroSettings(pomodoro);
+    return result.success && result.data ? result.data : false;
+  }
+
+  async updateSettingCompat<K extends keyof AppSettings>(
+    key: K,
+    value: AppSettings[K],
+  ): Promise<boolean> {
+    const result = await this.updateSetting(key, value);
+    return result.success && result.data ? result.data : false;
+  }
+
+  async resetToDefaultsCompat(): Promise<boolean> {
+    const result = await this.resetToDefaults();
+    return result.success && result.data ? result.data : false;
+  }
+
   // Validation helpers
   static validateWorkDuration(minutes: number): boolean {
     return minutes >= 5 && minutes <= 90;
diff --git a/src/services/SupabaseAuthService.ts b/src/services/SupabaseAuthService.ts
index 52fe219..3beb2d9 100644
--- a/src/services/SupabaseAuthService.ts
+++ b/src/services/SupabaseAuthService.ts
@@ -5,7 +5,7 @@ import { supabase } from './SupabaseService';
 // import type { Database } from '../types/database.types'; // Will be used when DbUser is needed
 import type { ICryptoService } from './CryptoService';
 import CryptoService from './CryptoService';
-import SecureLogger from './SecureLogger';
+import { BaseService } from './BaseService';
 import type { IRateLimiter } from './RateLimiter';
 import RateLimiter from './RateLimiter';
 import ValidationService from './ValidationService';
@@ -24,7 +24,7 @@ import UserStorageService from './UserStorageService';
 
 // type DbUser = Database['public']['Tables']['users']['Row']; // Will be used in future
 
-export class SupabaseAuthService implements IAuthService {
+export class SupabaseAuthService extends BaseService implements IAuthService {
   // Password validation rules (same as original)
   static readonly PASSWORD_MIN_LENGTH = 8;
   static readonly PASSWORD_REQUIRE_UPPERCASE = true;
@@ -40,6 +40,7 @@ export class SupabaseAuthService implements IAuthService {
     cryptoService: ICryptoService = CryptoService,
     rateLimiter: IRateLimiter = RateLimiter,
   ) {
+    super('SupabaseAuthService');
     this.cryptoService = cryptoService;
     this.rateLimiter = rateLimiter;
 
@@ -55,17 +56,17 @@ export class SupabaseAuthService implements IAuthService {
     supabase.auth.onAuthStateChange((event, session) => {
       if (event === 'SIGNED_IN' && session?.user) {
         // Handle sign in
-        SecureLogger.info('User signed in via Supabase', {
+        this.logger.info('User signed in via Supabase', {
           code: 'SUPABASE_AUTH_001',
         });
       } else if (event === 'SIGNED_OUT') {
         // Handle sign out
-        SecureLogger.info('User signed out via Supabase', {
+        this.logger.info('User signed out via Supabase', {
           code: 'SUPABASE_AUTH_002',
         });
       } else if (event === 'TOKEN_REFRESHED') {
         // Handle token refresh
-        SecureLogger.info('Session token refreshed', {
+        this.logger.info('Session token refreshed', {
           code: 'SUPABASE_AUTH_003',
         });
       }
@@ -113,162 +114,168 @@ export class SupabaseAuthService implements IAuthService {
 
   // Sign up a new user
   async signUp(email: string, password: string, name: string, role: UserRole): Promise<AuthResult> {
-    try {
-      // Check if Supabase is available
-      if (!supabase) {
-        throw new Error('Supabase client not initialized');
-      }
+    const result = await this.wrapAsync(
+      'signUp',
+      async () => {
+        // Check if Supabase is available
+        if (!supabase) {
+          throw new Error('Supabase client not initialized');
+        }
 
-      // Validate email format
-      if (!ValidationService.validateEmail(email)) {
-        throw new Error('Invalid email address');
-      }
+        // Validate email format
+        if (!ValidationService.validateEmail(email)) {
+          throw new Error('Invalid email address');
+        }
 
-      // Validate password
-      const passwordValidation = this.validatePassword(password);
-      if (!passwordValidation.isValid) {
-        throw new Error(passwordValidation.errors.join('. '));
-      }
+        // Validate password
+        const passwordValidation = this.validatePassword(password);
+        if (!passwordValidation.isValid) {
+          throw new Error(passwordValidation.errors.join('. '));
+        }
 
-      // Create user in Supabase Auth
-      const { data: authData, error: authError } = await supabase.auth.signUp({
-        email: email.toLowerCase(),
-        password,
-        options: {
-          data: {
-            name,
-            role,
+        // Create user in Supabase Auth
+        const { data: authData, error: authError } = await supabase.auth.signUp({
+          email: email.toLowerCase(),
+          password,
+          options: {
+            data: {
+              name,
+              role,
+            },
           },
-        },
-      });
+        });
 
-      if (authError) {
-        throw new Error(authError.message);
-      }
+        if (authError) {
+          throw new Error(authError.message);
+        }
 
-      if (!authData.user) {
-        throw new Error('Failed to create user account');
-      }
+        if (!authData.user) {
+          throw new Error('Failed to create user account');
+        }
 
-      // Create user profile in database
-      const { error: profileError } = await supabase.from('users').insert({
-        id: authData.user.id,
-        email: email.toLowerCase(),
-        name,
-        theme: 'system',
-        notification_preferences: { global: 'all' },
-      });
+        // Create user profile in database
+        const { error: profileError } = await supabase.from('users').insert({
+          id: authData.user.id,
+          email: email.toLowerCase(),
+          name,
+          theme: 'system',
+          notification_preferences: { global: 'all' },
+        });
 
-      if (profileError) {
-        // Rollback auth user if profile creation fails
-        await supabase.auth.admin.deleteUser(authData.user.id);
-        throw new Error('Failed to create user profile');
-      }
+        if (profileError) {
+          // Rollback auth user if profile creation fails
+          await supabase.auth.admin.deleteUser(authData.user.id);
+          throw new Error('Failed to create user profile');
+        }
 
-      // Create secure token for device binding (compatible with original implementation)
-      const secureToken = await this.createSecureToken(authData.user.id);
-      await this.storeSecureToken(authData.user.id, secureToken);
+        // Create secure token for device binding (compatible with original implementation)
+        const secureToken = await this.createSecureToken(authData.user.id);
+        await this.storeSecureToken(authData.user.id, secureToken);
 
-      // Get session token
-      const {
-        data: { session },
-      } = await supabase.auth.getSession();
-      const token = session?.access_token ?? '';
+        // Get session token
+        const {
+          data: { session },
+        } = await supabase.auth.getSession();
+        const token = session?.access_token ?? '';
 
-      // Transform to match original User type
-      const user = this.transformSupabaseUser(authData.user, { name, role });
+        // Transform to match original User type
+        const user = this.transformSupabaseUser(authData.user, { name, role });
 
-      return {
-        success: true,
-        user: this.sanitizeUser(user),
-        token,
-      };
-    } catch (error) {
-      SecureLogger.error('Sign up failed', {
-        code: 'SUPABASE_SIGNUP_001',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return {
-        success: false,
-        error: error instanceof Error ? error.message : 'Unknown error occurred',
-      };
+        return {
+          success: true,
+          user: this.sanitizeUser(user),
+          token,
+        };
+      },
+      { email: email.toLowerCase(), role },
+    );
+
+    if (result.success) {
+      return result.data!;
     }
+    return {
+      success: false,
+      error: result.error!.message,
+    };
   }
 
   // Login an existing user
   async login(email: string, password: string): Promise<AuthResult> {
-    try {
-      // Validate inputs
-      if (!email || !password) {
-        throw new Error('Email and password are required');
-      }
+    const result = await this.wrapAsync(
+      'login',
+      async () => {
+        // Validate inputs
+        if (!email || !password) {
+          throw new Error('Email and password are required');
+        }
 
-      // Check rate limiting
-      if (!this.rateLimiter.canAttemptLogin(email)) {
-        const lockoutEnd = this.rateLimiter.getLockoutEndTime(email);
-        const minutesRemaining = lockoutEnd ? Math.ceil((lockoutEnd - Date.now()) / 60000) : 15;
-        throw new Error(
-          `Too many failed login attempts. Please try again in ${minutesRemaining} minutes.`,
-        );
-      }
+        // Check rate limiting
+        if (!this.rateLimiter.canAttemptLogin(email)) {
+          const lockoutEnd = this.rateLimiter.getLockoutEndTime(email);
+          const minutesRemaining = lockoutEnd ? Math.ceil((lockoutEnd - Date.now()) / 60000) : 15;
+          throw new Error(
+            `Too many failed login attempts. Please try again in ${minutesRemaining} minutes.`,
+          );
+        }
 
-      // Sign in with Supabase
-      const { data, error } = await supabase.auth.signInWithPassword({
-        email: email.toLowerCase(),
-        password,
-      });
+        // Sign in with Supabase
+        const { data, error } = await supabase.auth.signInWithPassword({
+          email: email.toLowerCase(),
+          password,
+        });
 
-      if (error) {
-        this.rateLimiter.recordLoginAttempt(email, false);
-        throw new Error('Invalid email or password');
-      }
+        if (error) {
+          this.rateLimiter.recordLoginAttempt(email, false);
+          throw new Error('Invalid email or password');
+        }
 
-      if (!data.user) {
-        throw new Error('Login failed');
-      }
+        if (!data.user) {
+          throw new Error('Login failed');
+        }
 
-      // Record successful login
-      this.rateLimiter.recordLoginAttempt(email, true);
+        // Record successful login
+        this.rateLimiter.recordLoginAttempt(email, true);
 
-      // Update last login time in database
-      await supabase
-        .from('users')
-        .update({ last_active: new Date().toISOString() })
-        .eq('id', data.user.id);
+        // Update last login time in database
+        await supabase
+          .from('users')
+          .update({ last_active: new Date().toISOString() })
+          .eq('id', data.user.id);
 
-      // Create secure token for device binding
-      const secureToken = await this.createSecureToken(data.user.id);
-      await this.storeSecureToken(data.user.id, secureToken);
+        // Create secure token for device binding
+        const secureToken = await this.createSecureToken(data.user.id);
+        await this.storeSecureToken(data.user.id, secureToken);
 
-      // Check if this is a user migrating from local storage
-      if (!this.migrationInProgress) {
-        await this.attemptDataMigration(data.user.id);
-      }
+        // Check if this is a user migrating from local storage
+        if (!this.migrationInProgress) {
+          await this.attemptDataMigration(data.user.id);
+        }
 
-      // Get user profile with role
-      const profile = await this.getUserProfile(data.user.id);
-      const user = this.transformSupabaseUser(data.user, profile);
+        // Get user profile with role
+        const profile = await this.getUserProfile(data.user.id);
+        const user = this.transformSupabaseUser(data.user, profile);
 
-      return {
-        success: true,
-        user: this.sanitizeUser(user),
-        token: data.session?.access_token || '',
-      };
-    } catch (error) {
-      SecureLogger.error('Login failed', {
-        code: 'SUPABASE_LOGIN_001',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return {
-        success: false,
-        error: error instanceof Error ? error.message : 'Unknown error occurred',
-      };
+        return {
+          success: true,
+          user: this.sanitizeUser(user),
+          token: data.session?.access_token || '',
+        };
+      },
+      { email: email.toLowerCase() },
+    );
+
+    if (result.success) {
+      return result.data!;
     }
+    return {
+      success: false,
+      error: result.error!.message,
+    };
   }
 
   // Verify current session
   async verifySession(): Promise<SessionVerificationResult> {
-    try {
+    const result = await this.wrapAsync('verifySession', async () => {
       const {
         data: { session },
         error,
@@ -295,7 +302,7 @@ export class SupabaseAuthService implements IAuthService {
         // Validate device binding
         const deviceId = await this.getDeviceId();
         if (secureToken.deviceId !== deviceId) {
-          SecureLogger.warn('Session accessed from different device', {
+          this.logger.warn('Session accessed from different device', {
             code: 'SUPABASE_SESSION_001',
           });
         }
@@ -319,18 +326,17 @@ export class SupabaseAuthService implements IAuthService {
         isValid: true,
         user: this.sanitizeUser(user),
       };
-    } catch (error) {
-      SecureLogger.error('Session verification failed', {
-        code: 'SUPABASE_SESSION_002',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return { isValid: false, reason: 'Verification error' };
+    });
+
+    if (result.success) {
+      return result.data!;
     }
+    return { isValid: false, reason: 'Verification error' };
   }
 
   // Logout current user
   async logout(): Promise<{ success: boolean; error?: string }> {
-    try {
+    const result = await this.wrapAsync('logout', async () => {
       const { error } = await supabase.auth.signOut();
 
       if (error) {
@@ -349,21 +355,20 @@ export class SupabaseAuthService implements IAuthService {
       await UserStorageService.logout();
 
       return { success: true };
-    } catch (error) {
-      SecureLogger.error('Logout failed', {
-        code: 'SUPABASE_LOGOUT_001',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return {
-        success: false,
-        error: error instanceof Error ? error.message : 'Unknown error occurred',
-      };
+    });
+
+    if (result.success) {
+      return result.data!;
     }
+    return {
+      success: false,
+      error: result.error!.message,
+    };
   }
 
   // Change password for current user
   async changePassword(currentPassword: string, newPassword: string): Promise<AuthResult> {
-    try {
+    const result = await this.wrapAsync('changePassword', async () => {
       const {
         data: { user },
       } = await supabase.auth.getUser();
@@ -400,43 +405,53 @@ export class SupabaseAuthService implements IAuthService {
       await this.rotateToken(user.id);
 
       return { success: true };
-    } catch (error) {
-      SecureLogger.error('Password change failed', {
-        code: 'SUPABASE_PASSWORD_001',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return {
-        success: false,
-        error: error instanceof Error ? error.message : 'Unknown error occurred',
-      };
+    });
+
+    if (result.success) {
+      return result.data!;
     }
+    return {
+      success: false,
+      error: result.error!.message,
+    };
   }
 
   // Reset password (for forgot password flow)
-  // eslint-disable-next-line @typescript-eslint/require-await
+
   async resetPassword(_email: string, _newPassword: string): Promise<PasswordResetResult> {
-    try {
-      // In a real implementation, this would send a reset email
-      // For now, we'll implement direct reset for development
+    const result = await this.wrapAsync(
+      'resetPassword',
+      async () => {
+        // In a real implementation, this would send a reset email
+        // For now, we'll implement direct reset for development
 
-      // This would typically be a two-step process:
-      // 1. Send reset email: await supabase.auth.resetPasswordForEmail(email)
-      // 2. Update password with token from email
+        // This would typically be a two-step process:
+        // 1. Send reset email: await supabase.auth.resetPasswordForEmail(email)
+        // 2. Update password with token from email
 
-      SecureLogger.info('Password reset requested', {
-        code: 'SUPABASE_RESET_001',
-      });
+        // Simulate async operation
+        await Promise.resolve();
 
-      return {
-        success: true,
-        message: 'If an account exists, a password reset email has been sent',
-      };
-    } catch (error) {
-      return {
-        success: false,
-        error: error instanceof Error ? error.message : 'Unknown error occurred',
-      };
+        this.logger.info('Password reset requested', {
+          code: 'SUPABASE_RESET_001',
+        });
+
+        const resetResult: PasswordResetResult = {
+          success: true,
+          message: 'If an account exists, a password reset email has been sent',
+        };
+        return resetResult;
+      },
+      { email: _email },
+    );
+
+    if (result.success && result.data) {
+      return result.data;
     }
+    return {
+      success: false,
+      message: result.error?.message ?? 'Password reset failed',
+    };
   }
 
   // Remove sensitive fields from user object
@@ -479,7 +494,7 @@ export class SupabaseAuthService implements IAuthService {
     try {
       const currentDeviceId = await this.getDeviceId();
       if (secureToken.deviceId !== currentDeviceId) {
-        SecureLogger.warn('Token used from different device', {
+        this.logger.warn('Token used from different device', {
           code: 'SUPABASE_TOKEN_001',
         });
         return false;
@@ -505,7 +520,7 @@ export class SupabaseAuthService implements IAuthService {
 
       return decryptedToken === providedToken;
     } catch (error) {
-      SecureLogger.error('Token validation failed', {
+      this.logger.error('Token validation failed', {
         code: 'SUPABASE_TOKEN_002',
       });
       return false;
@@ -538,7 +553,7 @@ export class SupabaseAuthService implements IAuthService {
 
       return token;
     } catch (error) {
-      SecureLogger.error('Failed to retrieve secure token', {
+      this.logger.error('Failed to retrieve secure token', {
         code: 'SUPABASE_TOKEN_003',
       });
       return null;
@@ -590,7 +605,7 @@ export class SupabaseAuthService implements IAuthService {
 
       return deviceKey;
     } catch (error) {
-      SecureLogger.error('Failed to manage device key', {
+      this.logger.error('Failed to manage device key', {
         code: 'SUPABASE_DEVICE_001',
       });
       throw new Error('Failed to manage device encryption key');
@@ -611,7 +626,7 @@ export class SupabaseAuthService implements IAuthService {
 
       return deviceId || 'unknown-device';
     } catch (error) {
-      SecureLogger.error('Failed to get device ID', {
+      this.logger.error('Failed to get device ID', {
         code: 'SUPABASE_DEVICE_002',
       });
       return 'unknown-device';
@@ -632,7 +647,7 @@ export class SupabaseAuthService implements IAuthService {
 
       return installationId || 'unknown-installation';
     } catch (error) {
-      SecureLogger.error('Failed to get installation ID', {
+      this.logger.error('Failed to get installation ID', {
         code: 'SUPABASE_DEVICE_003',
       });
       return 'unknown-installation';
@@ -642,7 +657,7 @@ export class SupabaseAuthService implements IAuthService {
   // eslint-disable-next-line @typescript-eslint/require-await
   async invalidateOtherSessions(_userId: string): Promise<void> {
     // In Supabase, this would be handled by the refresh token rotation
-    SecureLogger.info('Token rotation initiated', {
+    this.logger.info('Token rotation initiated', {
       code: 'SUPABASE_TOKEN_ROTATE_001',
     });
   }
@@ -652,7 +667,7 @@ export class SupabaseAuthService implements IAuthService {
     const timeSinceLastUse = now - secureToken.lastUsedAt.getTime();
 
     if (timeSinceLastUse < 1000) {
-      SecureLogger.warn('Suspicious rapid token usage detected', {
+      this.logger.warn('Suspicious rapid token usage detected', {
         code: 'SUPABASE_ANOMALY_001',
       });
       return true;
@@ -672,7 +687,7 @@ export class SupabaseAuthService implements IAuthService {
     }>();
 
     if (error || !data) {
-      SecureLogger.error('Failed to fetch user profile', {
+      this.logger.error('Failed to fetch user profile', {
         code: 'SUPABASE_PROFILE_001',
       });
       return {};
@@ -749,7 +764,7 @@ export class SupabaseAuthService implements IAuthService {
       // Check for local user data
       const localUser = await UserStorageService.getCurrentUser();
       if (localUser?.email) {
-        SecureLogger.info('Attempting data migration for user', {
+        this.logger.info('Attempting data migration for user', {
           code: 'SUPABASE_MIGRATE_001',
         });
 
@@ -760,7 +775,7 @@ export class SupabaseAuthService implements IAuthService {
         await SecureStore.setItemAsync(migrationKey, 'true');
       }
     } catch (error) {
-      SecureLogger.error('Data migration failed', {
+      this.logger.error('Data migration failed', {
         code: 'SUPABASE_MIGRATE_002',
         context: error instanceof Error ? error.message : 'Unknown error',
       });
diff --git a/src/services/TaskStorageService.ts b/src/services/TaskStorageService.ts
index 78eaf17..4671f7f 100644
--- a/src/services/TaskStorageService.ts
+++ b/src/services/TaskStorageService.ts
@@ -1,8 +1,8 @@
 // ABOUTME: Simplified TaskStorageService that directly uses Supabase for all task storage
 // No local storage fallback, no migration logic - pure Supabase implementation
 
+import { BaseService } from './BaseService';
 import { supabase } from './SupabaseService';
-import SecureLogger from './SecureLogger';
 import type { Task, PartnerNotificationStatus } from '../types/task.types';
 import { TaskStatus, TaskPriority } from '../types/task.types';
 import type { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js';
@@ -66,12 +66,16 @@ interface DbTask {
   updated_at?: string;
 }
 
-class TaskStorageService implements ITaskStorageService {
+class TaskStorageService extends BaseService implements ITaskStorageService {
   private taskCache = new Map<string, Task[]>();
   private cacheTimestamp = new Map<string, number>();
   private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
   private subscriptions = new Map<string, RealtimeChannel>();
 
+  constructor() {
+    super('TaskStorage');
+  }
+
   private transformDbTaskToTask(dbTask: DbTask): Task {
     return {
       id: dbTask.id,
@@ -150,7 +154,7 @@ class TaskStorageService implements ITaskStorageService {
   }
 
   async getAllTasks(): Promise<Task[]> {
-    try {
+    const result = await this.wrapAsync('getAllTasks', async () => {
       const {
         data: { user },
       } = await supabase.auth.getUser();
@@ -168,130 +172,110 @@ class TaskStorageService implements ITaskStorageService {
         .order('created_at', { ascending: false });
 
       if (error) {
-        SecureLogger.error('Failed to fetch all tasks', {
-          code: 'TASK_001',
-          context: error.message,
-        });
-        return [];
+        throw new Error(`Failed to fetch tasks: ${error.message}`);
       }
 
       const tasks = (data ?? []).map(this.transformDbTaskToTask);
       this.updateCache(cacheKey, tasks);
       return tasks;
-    } catch (error) {
-      SecureLogger.error('Failed to get all tasks', {
-        code: 'TASK_002',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return [];
-    }
+    });
+
+    return result.success && result.data ? result.data : [];
   }
 
   async saveTask(task: Task): Promise<boolean> {
-    try {
-      const {
-        data: { user },
-      } = await supabase.auth.getUser();
-      if (!user) return false;
+    const result = await this.wrapAsync(
+      'saveTask',
+      async () => {
+        const {
+          data: { user },
+        } = await supabase.auth.getUser();
+        if (!user) return false;
 
-      const dbTask = this.transformTaskToDb(task);
-      dbTask.user_id = user.id;
+        const dbTask = this.transformTaskToDb(task);
+        dbTask.user_id = user.id;
 
-      const { error } = await supabase.from('tasks').insert(dbTask).select().single();
+        const { error } = await supabase.from('tasks').insert(dbTask).select().single();
 
-      if (error) {
-        SecureLogger.error('Failed to save task', {
-          code: 'TASK_003',
-          context: error.message,
-        });
-        return false;
-      }
+        if (error) {
+          throw new Error(`Failed to save task: ${error.message}`);
+        }
 
-      // Invalidate cache for this user
-      this.invalidateCache(user.id);
+        // Invalidate cache for this user
+        this.invalidateCache(user.id);
 
-      return true;
-    } catch (error) {
-      SecureLogger.error('Failed to save task', {
-        code: 'TASK_004',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+        return true;
+      },
+      { taskId: task.id, title: task.title },
+    );
+
+    return result.success && result.data === true;
   }
 
   async updateTask(updatedTask: Task): Promise<boolean> {
-    try {
-      const {
-        data: { user },
-      } = await supabase.auth.getUser();
-      if (!user) return false;
-
-      const dbTask = this.transformTaskToDb(updatedTask);
-
-      const { error } = await supabase
-        .from('tasks')
-        .update(dbTask)
-        .eq('id', updatedTask.id)
-        .or(`user_id.eq.${user.id},assigned_to.eq.${user.id}`);
+    const result = await this.wrapAsync(
+      'updateTask',
+      async () => {
+        const {
+          data: { user },
+        } = await supabase.auth.getUser();
+        if (!user) return false;
+
+        const dbTask = this.transformTaskToDb(updatedTask);
+
+        const { error } = await supabase
+          .from('tasks')
+          .update(dbTask)
+          .eq('id', updatedTask.id)
+          .or(`user_id.eq.${user.id},assigned_to.eq.${user.id}`);
+
+        if (error) {
+          throw new Error(`Failed to update task: ${error.message}`);
+        }
 
-      if (error) {
-        SecureLogger.error('Failed to update task', {
-          code: 'TASK_005',
-          context: error.message,
-        });
-        return false;
-      }
+        // Invalidate cache for this user
+        this.invalidateCache(user.id);
 
-      // Invalidate cache for this user
-      this.invalidateCache(user.id);
+        return true;
+      },
+      { taskId: updatedTask.id, title: updatedTask.title },
+    );
 
-      return true;
-    } catch (error) {
-      SecureLogger.error('Failed to update task', {
-        code: 'TASK_006',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+    return result.success && result.data === true;
   }
 
   async deleteTask(taskId: string): Promise<boolean> {
-    try {
-      const {
-        data: { user },
-      } = await supabase.auth.getUser();
-      if (!user) return false;
-
-      const { error } = await supabase
-        .from('tasks')
-        .delete()
-        .eq('id', taskId)
-        .eq('user_id', user.id);
+    const result = await this.wrapAsync(
+      'deleteTask',
+      async () => {
+        const {
+          data: { user },
+        } = await supabase.auth.getUser();
+        if (!user) return false;
+
+        const { error } = await supabase
+          .from('tasks')
+          .delete()
+          .eq('id', taskId)
+          .eq('user_id', user.id);
+
+        if (error) {
+          throw new Error(`Failed to delete task: ${error.message}`);
+        }
 
-      if (error) {
-        SecureLogger.error('Failed to delete task', {
-          code: 'TASK_007',
-          context: error.message,
-        });
-        return false;
-      }
+        // Invalidate cache for this user
+        this.invalidateCache(user.id);
 
-      // Invalidate cache for this user
-      this.invalidateCache(user.id);
+        return true;
+      },
+      { taskId },
+    );
 
-      return true;
-    } catch (error) {
-      SecureLogger.error('Failed to delete task', {
-        code: 'TASK_008',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+    return result.success && result.data === true;
   }
 
   async clearAllTasks(): Promise<boolean> {
-    try {
+    const result = await this.wrapAsync('clearAllTasks', async () => {
       const {
         data: { user },
       } = await supabase.auth.getUser();
@@ -300,78 +284,66 @@ class TaskStorageService implements ITaskStorageService {
       const { error } = await supabase.from('tasks').delete().eq('user_id', user.id);
 
       if (error) {
-        SecureLogger.error('Failed to clear all tasks', {
-          code: 'TASK_009',
-          context: error.message,
-        });
-        return false;
+        throw new Error(`Failed to clear all tasks: ${error.message}`);
       }
 
       // Invalidate all caches for this user
       this.invalidateCache(user.id);
 
       return true;
-    } catch (error) {
-      SecureLogger.error('Failed to clear all tasks', {
-        code: 'TASK_010',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+    });
+
+    return result.success && result.data === true;
   }
 
   async getTasksByCategory(categoryId: string, options?: TaskStorageOptions): Promise<Task[]> {
-    try {
-      const {
-        data: { user },
-      } = await supabase.auth.getUser();
-      if (!user) return [];
+    const result = await this.wrapAsync(
+      'getTasksByCategory',
+      async () => {
+        const {
+          data: { user },
+        } = await supabase.auth.getUser();
+        if (!user) return [];
+
+        const cacheKey = `category:${user.id}:${categoryId}`;
+        if (this.isCacheValid(cacheKey) && !options?.page) {
+          return this.taskCache.get(cacheKey) ?? [];
+        }
 
-      const cacheKey = `category:${user.id}:${categoryId}`;
-      if (this.isCacheValid(cacheKey) && !options?.page) {
-        return this.taskCache.get(cacheKey) ?? [];
-      }
+        let query = supabase
+          .from('tasks')
+          .select('*')
+          .or(`user_id.eq.${user.id},assigned_to.eq.${user.id}`)
+          .eq('category', categoryId)
+          .order('created_at', { ascending: false });
 
-      let query = supabase
-        .from('tasks')
-        .select('*')
-        .or(`user_id.eq.${user.id},assigned_to.eq.${user.id}`)
-        .eq('category', categoryId)
-        .order('created_at', { ascending: false });
+        if (options?.page && options?.pageSize) {
+          const offset = (options.page - 1) * options.pageSize;
+          query = query.range(offset, offset + options.pageSize - 1);
+        }
 
-      if (options?.page && options?.pageSize) {
-        const offset = (options.page - 1) * options.pageSize;
-        query = query.range(offset, offset + options.pageSize - 1);
-      }
+        const { data, error } = await query;
 
-      const { data, error } = await query;
+        if (error) {
+          throw new Error(`Failed to fetch tasks by category: ${error.message}`);
+        }
 
-      if (error) {
-        SecureLogger.error('Failed to fetch tasks by category', {
-          code: 'TASK_011',
-          context: error.message,
-        });
-        return [];
-      }
+        const tasks = (data ?? []).map(this.transformDbTaskToTask);
 
-      const tasks = (data ?? []).map(this.transformDbTaskToTask);
+        if (!options?.page) {
+          this.updateCache(cacheKey, tasks);
+        }
 
-      if (!options?.page) {
-        this.updateCache(cacheKey, tasks);
-      }
+        return tasks;
+      },
+      { categoryId, options },
+    );
 
-      return tasks;
-    } catch (error) {
-      SecureLogger.error('Failed to get tasks by category', {
-        code: 'TASK_012',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return [];
-    }
+    return result.success && result.data ? result.data : [];
   }
 
   async getCompletedTasks(): Promise<Task[]> {
-    try {
+    const result = await this.wrapAsync('getCompletedTasks', async () => {
       const {
         data: { user },
       } = await supabase.auth.getUser();
@@ -385,25 +357,17 @@ class TaskStorageService implements ITaskStorageService {
         .order('completed_at', { ascending: false });
 
       if (error) {
-        SecureLogger.error('Failed to fetch completed tasks', {
-          code: 'TASK_013',
-          context: error.message,
-        });
-        return [];
+        throw new Error(`Failed to fetch completed tasks: ${error.message}`);
       }
 
       return (data ?? []).map(this.transformDbTaskToTask);
-    } catch (error) {
-      SecureLogger.error('Failed to get completed tasks', {
-        code: 'TASK_014',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return [];
-    }
+    });
+
+    return result.success && result.data ? result.data : [];
   }
 
   async getPendingTasks(): Promise<Task[]> {
-    try {
+    const result = await this.wrapAsync('getPendingTasks', async () => {
       const {
         data: { user },
       } = await supabase.auth.getUser();
@@ -417,25 +381,17 @@ class TaskStorageService implements ITaskStorageService {
         .order('created_at', { ascending: false });
 
       if (error) {
-        SecureLogger.error('Failed to fetch pending tasks', {
-          code: 'TASK_015',
-          context: error.message,
-        });
-        return [];
+        throw new Error(`Failed to fetch pending tasks: ${error.message}`);
       }
 
       return (data ?? []).map(this.transformDbTaskToTask);
-    } catch (error) {
-      SecureLogger.error('Failed to get pending tasks', {
-        code: 'TASK_016',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return [];
-    }
+    });
+
+    return result.success && result.data ? result.data : [];
   }
 
   async getTaskStats(): Promise<TaskStats> {
-    try {
+    const result = await this.wrapAsync('getTaskStats', async () => {
       const {
         data: { user },
       } = await supabase.auth.getUser();
@@ -449,11 +405,7 @@ class TaskStorageService implements ITaskStorageService {
         .or(`user_id.eq.${user.id},assigned_to.eq.${user.id}`);
 
       if (error) {
-        SecureLogger.error('Failed to fetch task stats', {
-          code: 'TASK_017',
-          context: error.message,
-        });
-        return { total: 0, completed: 0, pending: 0, totalXP: 0 };
+        throw new Error(`Failed to fetch task stats: ${error.message}`);
       }
 
       const tasks = data ?? [];
@@ -465,180 +417,154 @@ class TaskStorageService implements ITaskStorageService {
       };
 
       return stats;
-    } catch (error) {
-      SecureLogger.error('Failed to get task stats', {
-        code: 'TASK_018',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return { total: 0, completed: 0, pending: 0, totalXP: 0 };
-    }
+    });
+
+    return result.success && result.data
+      ? result.data
+      : { total: 0, completed: 0, pending: 0, totalXP: 0 };
   }
 
   async getTasksForUser(userId: string): Promise<Task[]> {
-    try {
-      const { data, error } = await supabase
-        .from('tasks')
-        .select('*')
-        .eq('user_id', userId)
-        .order('created_at', { ascending: false });
+    const result = await this.wrapAsync(
+      'getTasksForUser',
+      async () => {
+        const { data, error } = await supabase
+          .from('tasks')
+          .select('*')
+          .eq('user_id', userId)
+          .order('created_at', { ascending: false });
+
+        if (error) {
+          throw new Error(`Failed to fetch tasks for user: ${error.message}`);
+        }
 
-      if (error) {
-        SecureLogger.error('Failed to fetch tasks for user', {
-          code: 'TASK_019',
-          context: error.message,
-        });
-        return [];
-      }
+        return (data ?? []).map(this.transformDbTaskToTask);
+      },
+      { userId },
+    );
 
-      return (data ?? []).map(this.transformDbTaskToTask);
-    } catch (error) {
-      SecureLogger.error('Failed to get tasks for user', {
-        code: 'TASK_020',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return [];
-    }
+    return result.success && result.data ? result.data : [];
   }
 
   async getTasksAssignedByUser(userId: string): Promise<Task[]> {
-    try {
-      const { data, error } = await supabase
-        .from('tasks')
-        .select('*')
-        .eq('assigned_by', userId)
-        .order('created_at', { ascending: false });
+    const result = await this.wrapAsync(
+      'getTasksAssignedByUser',
+      async () => {
+        const { data, error } = await supabase
+          .from('tasks')
+          .select('*')
+          .eq('assigned_by', userId)
+          .order('created_at', { ascending: false });
+
+        if (error) {
+          throw new Error(`Failed to fetch tasks assigned by user: ${error.message}`);
+        }
 
-      if (error) {
-        SecureLogger.error('Failed to fetch tasks assigned by user', {
-          code: 'TASK_021',
-          context: error.message,
-        });
-        return [];
-      }
+        return (data ?? []).map(this.transformDbTaskToTask);
+      },
+      { userId },
+    );
 
-      return (data ?? []).map(this.transformDbTaskToTask);
-    } catch (error) {
-      SecureLogger.error('Failed to get tasks assigned by user', {
-        code: 'TASK_022',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return [];
-    }
+    return result.success && result.data ? result.data : [];
   }
 
   async getAssignedTasks(userId: string): Promise<Task[]> {
-    try {
-      const { data, error } = await supabase
-        .from('tasks')
-        .select('*')
-        .eq('assigned_to', userId)
-        .order('created_at', { ascending: false });
+    const result = await this.wrapAsync(
+      'getAssignedTasks',
+      async () => {
+        const { data, error } = await supabase
+          .from('tasks')
+          .select('*')
+          .eq('assigned_to', userId)
+          .order('created_at', { ascending: false });
+
+        if (error) {
+          throw new Error(`Failed to fetch assigned tasks: ${error.message}`);
+        }
 
-      if (error) {
-        SecureLogger.error('Failed to fetch assigned tasks', {
-          code: 'TASK_023',
-          context: error.message,
-        });
-        return [];
-      }
+        return (data ?? []).map(this.transformDbTaskToTask);
+      },
+      { userId },
+    );
 
-      return (data ?? []).map(this.transformDbTaskToTask);
-    } catch (error) {
-      SecureLogger.error('Failed to get assigned tasks', {
-        code: 'TASK_024',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return [];
-    }
+    return result.success && result.data ? result.data : [];
   }
 
   async getPartnerTasks(userId: string): Promise<Task[]> {
-    try {
-      const { data, error } = await supabase
-        .from('tasks')
-        .select('*')
-        .or(`assigned_by.eq.${userId},assigned_to.eq.${userId}`)
-        .neq('user_id', userId)
-        .order('created_at', { ascending: false });
+    const result = await this.wrapAsync(
+      'getPartnerTasks',
+      async () => {
+        const { data, error } = await supabase
+          .from('tasks')
+          .select('*')
+          .or(`assigned_by.eq.${userId},assigned_to.eq.${userId}`)
+          .neq('user_id', userId)
+          .order('created_at', { ascending: false });
+
+        if (error) {
+          throw new Error(`Failed to fetch partner tasks: ${error.message}`);
+        }
 
-      if (error) {
-        SecureLogger.error('Failed to fetch partner tasks', {
-          code: 'TASK_025',
-          context: error.message,
-        });
-        return [];
-      }
+        return (data ?? []).map(this.transformDbTaskToTask);
+      },
+      { userId },
+    );
 
-      return (data ?? []).map(this.transformDbTaskToTask);
-    } catch (error) {
-      SecureLogger.error('Failed to get partner tasks', {
-        code: 'TASK_026',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return [];
-    }
+    return result.success && result.data ? result.data : [];
   }
 
   async getOverdueTasks(userId: string): Promise<Task[]> {
-    try {
-      const now = new Date().toISOString();
-
-      const { data, error } = await supabase
-        .from('tasks')
-        .select('*')
-        .or(`user_id.eq.${userId},assigned_to.eq.${userId}`)
-        .lt('due_date', now)
-        .neq('status', TaskStatus.COMPLETED)
-        .order('due_date', { ascending: true });
+    const result = await this.wrapAsync(
+      'getOverdueTasks',
+      async () => {
+        const now = new Date().toISOString();
+
+        const { data, error } = await supabase
+          .from('tasks')
+          .select('*')
+          .or(`user_id.eq.${userId},assigned_to.eq.${userId}`)
+          .lt('due_date', now)
+          .neq('status', TaskStatus.COMPLETED)
+          .order('due_date', { ascending: true });
+
+        if (error) {
+          throw new Error(`Failed to fetch overdue tasks: ${error.message}`);
+        }
 
-      if (error) {
-        SecureLogger.error('Failed to fetch overdue tasks', {
-          code: 'TASK_027',
-          context: error.message,
-        });
-        return [];
-      }
+        return (data ?? []).map(this.transformDbTaskToTask);
+      },
+      { userId },
+    );
 
-      return (data ?? []).map(this.transformDbTaskToTask);
-    } catch (error) {
-      SecureLogger.error('Failed to get overdue tasks', {
-        code: 'TASK_028',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return [];
-    }
+    return result.success && result.data ? result.data : [];
   }
 
   async getUpcomingTasks(userId: string, hoursAhead: number = 24): Promise<Task[]> {
-    try {
-      const now = new Date();
-      const future = new Date(now.getTime() + hoursAhead * 60 * 60 * 1000);
-
-      const { data, error } = await supabase
-        .from('tasks')
-        .select('*')
-        .or(`user_id.eq.${userId},assigned_to.eq.${userId}`)
-        .gte('due_date', now.toISOString())
-        .lte('due_date', future.toISOString())
-        .neq('status', TaskStatus.COMPLETED)
-        .order('due_date', { ascending: true });
+    const result = await this.wrapAsync(
+      'getUpcomingTasks',
+      async () => {
+        const now = new Date();
+        const future = new Date(now.getTime() + hoursAhead * 60 * 60 * 1000);
+
+        const { data, error } = await supabase
+          .from('tasks')
+          .select('*')
+          .or(`user_id.eq.${userId},assigned_to.eq.${userId}`)
+          .gte('due_date', now.toISOString())
+          .lte('due_date', future.toISOString())
+          .neq('status', TaskStatus.COMPLETED)
+          .order('due_date', { ascending: true });
+
+        if (error) {
+          throw new Error(`Failed to fetch upcoming tasks: ${error.message}`);
+        }
 
-      if (error) {
-        SecureLogger.error('Failed to fetch upcoming tasks', {
-          code: 'TASK_029',
-          context: error.message,
-        });
-        return [];
-      }
+        return (data ?? []).map(this.transformDbTaskToTask);
+      },
+      { userId, hoursAhead },
+    );
 
-      return (data ?? []).map(this.transformDbTaskToTask);
-    } catch (error) {
-      SecureLogger.error('Failed to get upcoming tasks', {
-        code: 'TASK_030',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return [];
-    }
+    return result.success && result.data ? result.data : [];
   }
 
   subscribeToTaskUpdates(
diff --git a/src/services/UserStorageService.ts b/src/services/UserStorageService.ts
index bbdae2a..c3eef07 100644
--- a/src/services/UserStorageService.ts
+++ b/src/services/UserStorageService.ts
@@ -3,7 +3,7 @@
 
 import * as SecureStore from 'expo-secure-store';
 import { supabase } from './SupabaseService';
-import SecureLogger from './SecureLogger';
+import { BaseService } from './BaseService';
 import type { User } from '../types/user.types';
 import { UserRole, NotificationPreference } from '../types/user.types';
 import type { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js';
@@ -48,19 +48,23 @@ interface AuthUser {
   created_at?: string;
 }
 
-class UserStorageService implements IUserStorageService {
+class UserStorageService extends BaseService implements IUserStorageService {
   private currentUserCache: User | null = null;
   private cacheTimestamp: number = 0;
   private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
   private subscriptions = new Map<string, RealtimeChannel>();
 
+  constructor() {
+    super('UserStorage');
+  }
+
   async getCurrentUser(): Promise<User | null> {
-    try {
-      // Check cache first
-      if (this.currentUserCache && Date.now() - this.cacheTimestamp < this.CACHE_DURATION) {
-        return this.currentUserCache;
-      }
+    // Check cache first
+    if (this.currentUserCache && Date.now() - this.cacheTimestamp < this.CACHE_DURATION) {
+      return this.currentUserCache;
+    }
 
+    const result = await this.wrapAsync('getCurrentUser', async () => {
       // Get current session
       const {
         data: { session },
@@ -68,7 +72,6 @@ class UserStorageService implements IUserStorageService {
       } = await supabase.auth.getSession();
 
       if (sessionError || !session) {
-        SecureLogger.info('No active session found', { code: 'USER_001' });
         return null;
       }
 
@@ -80,11 +83,7 @@ class UserStorageService implements IUserStorageService {
         .single<DbUser>();
 
       if (profileError || !profile) {
-        SecureLogger.error('Failed to fetch user profile', {
-          code: 'USER_002',
-          context: profileError?.message ?? 'No profile found',
-        });
-        return null;
+        throw new Error(profileError?.message ?? 'No profile found');
       }
 
       // Transform database user to User type
@@ -95,60 +94,51 @@ class UserStorageService implements IUserStorageService {
       this.cacheTimestamp = Date.now();
 
       return user;
-    } catch (error) {
-      SecureLogger.error('Failed to get current user', {
-        code: 'USER_003',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return null;
-    }
+    });
+
+    return result.success && result.data ? result.data : null;
   }
 
   async setCurrentUser(user: User): Promise<boolean> {
-    try {
-      // Update cache
-      this.currentUserCache = user;
-      this.cacheTimestamp = Date.now();
-
-      // Update user profile in database
-      const { error } = await supabase
-        .from('users')
-        .update({
-          name: user.name,
-          theme: user.theme ?? 'system',
-          notification_preferences: user.notificationPreferences ?? {
-            global: NotificationPreference.ALL,
-          },
-          encouragement_messages: user.encouragementMessages ?? [],
-          partner_id: user.partnerId,
-          xp_total: user.stats?.totalXP ?? 0,
-          current_streak: user.stats?.currentStreak ?? 0,
-          longest_streak: user.stats?.longestStreak ?? 0,
-          last_active: new Date().toISOString(),
-        })
-        .eq('id', user.id);
+    const result = await this.wrapAsync(
+      'setCurrentUser',
+      async () => {
+        // Update cache
+        this.currentUserCache = user;
+        this.cacheTimestamp = Date.now();
 
-      if (error) {
-        throw error;
-      }
+        // Update user profile in database
+        const { error } = await supabase
+          .from('users')
+          .update({
+            name: user.name,
+            theme: user.theme ?? 'system',
+            notification_preferences: user.notificationPreferences ?? {
+              global: NotificationPreference.ALL,
+            },
+            encouragement_messages: user.encouragementMessages ?? [],
+            partner_id: user.partnerId,
+            xp_total: user.stats?.totalXP ?? 0,
+            current_streak: user.stats?.currentStreak ?? 0,
+            longest_streak: user.stats?.longestStreak ?? 0,
+            last_active: new Date().toISOString(),
+          })
+          .eq('id', user.id);
+
+        if (error) {
+          throw error;
+        }
 
-      SecureLogger.info('Current user updated', {
-        code: 'USER_004',
-        context: `User: ${user.id}`,
-      });
+        return true;
+      },
+      { userId: user.id },
+    );
 
-      return true;
-    } catch (error) {
-      SecureLogger.error('Failed to set current user', {
-        code: 'USER_005',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+    return result.success && result.data ? result.data : false;
   }
 
   async getAllUsers(): Promise<User[]> {
-    try {
+    const result = await this.wrapAsync('getAllUsers', async () => {
       // In Supabase context, we typically only have access to current user
       // This method might be used for partner functionality
       const currentUser = await this.getCurrentUser();
@@ -174,134 +164,130 @@ class UserStorageService implements IUserStorageService {
       }
 
       return users;
-    } catch (error) {
-      SecureLogger.error('Failed to get all users', {
-        code: 'USER_006',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return [];
-    }
+    });
+
+    return result.success && result.data ? result.data : [];
   }
 
   async saveUser(user: User): Promise<boolean> {
-    try {
-      // In Supabase, users are created through auth flow
-      // This method updates existing user data
-      const { error } = await supabase.from('users').upsert({
-        id: user.id,
-        email: user.email,
-        name: user.name,
-        theme: user.theme ?? 'system',
-        notification_preferences: user.notificationPreferences ?? {
-          global: NotificationPreference.ALL,
-        },
-        encouragement_messages: user.encouragementMessages ?? [],
-        partner_id: user.partnerId,
-        xp_total: user.stats?.totalXP ?? 0,
-        current_streak: user.stats?.currentStreak ?? 0,
-        longest_streak: user.stats?.longestStreak ?? 0,
-        last_active: new Date().toISOString(),
-      });
+    const result = await this.wrapAsync(
+      'saveUser',
+      async () => {
+        // In Supabase, users are created through auth flow
+        // This method updates existing user data
+        const { error } = await supabase.from('users').upsert({
+          id: user.id,
+          email: user.email,
+          name: user.name,
+          theme: user.theme ?? 'system',
+          notification_preferences: user.notificationPreferences ?? {
+            global: NotificationPreference.ALL,
+          },
+          encouragement_messages: user.encouragementMessages ?? [],
+          partner_id: user.partnerId,
+          xp_total: user.stats?.totalXP ?? 0,
+          current_streak: user.stats?.currentStreak ?? 0,
+          longest_streak: user.stats?.longestStreak ?? 0,
+          last_active: new Date().toISOString(),
+        });
 
-      if (error) {
-        throw error;
-      }
+        if (error) {
+          throw error;
+        }
 
-      return true;
-    } catch (error) {
-      SecureLogger.error('Failed to save user', {
-        code: 'USER_007',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+        return true;
+      },
+      { userId: user.id },
+    );
+
+    return result.success && result.data ? result.data : false;
   }
 
   async updateUser(updatedUser: User): Promise<boolean> {
-    try {
-      const { error } = await supabase
-        .from('users')
-        .update({
-          name: updatedUser.name,
-          theme: updatedUser.theme ?? 'system',
-          notification_preferences: updatedUser.notificationPreferences ?? {
-            global: NotificationPreference.ALL,
-          },
-          encouragement_messages: updatedUser.encouragementMessages ?? [],
-          partner_id: updatedUser.partnerId,
-          xp_total: updatedUser.stats?.totalXP ?? 0,
-          current_streak: updatedUser.stats?.currentStreak ?? 0,
-          longest_streak: updatedUser.stats?.longestStreak ?? 0,
-          last_active: new Date().toISOString(),
-        })
-        .eq('id', updatedUser.id);
+    const result = await this.wrapAsync(
+      'updateUser',
+      async () => {
+        const { error } = await supabase
+          .from('users')
+          .update({
+            name: updatedUser.name,
+            theme: updatedUser.theme ?? 'system',
+            notification_preferences: updatedUser.notificationPreferences ?? {
+              global: NotificationPreference.ALL,
+            },
+            encouragement_messages: updatedUser.encouragementMessages ?? [],
+            partner_id: updatedUser.partnerId,
+            xp_total: updatedUser.stats?.totalXP ?? 0,
+            current_streak: updatedUser.stats?.currentStreak ?? 0,
+            longest_streak: updatedUser.stats?.longestStreak ?? 0,
+            last_active: new Date().toISOString(),
+          })
+          .eq('id', updatedUser.id);
+
+        if (error) {
+          throw error;
+        }
 
-      if (error) {
-        throw error;
-      }
+        // Update cache if it's the current user
+        if (this.currentUserCache?.id === updatedUser.id) {
+          this.currentUserCache = updatedUser;
+          this.cacheTimestamp = Date.now();
+        }
 
-      // Update cache if it's the current user
-      if (this.currentUserCache?.id === updatedUser.id) {
-        this.currentUserCache = updatedUser;
-        this.cacheTimestamp = Date.now();
-      }
+        return true;
+      },
+      { userId: updatedUser.id },
+    );
 
-      return true;
-    } catch (error) {
-      SecureLogger.error('Failed to update user', {
-        code: 'USER_008',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+    return result.success && result.data ? result.data : false;
   }
 
   async getUserById(userId: string): Promise<User | null> {
-    try {
-      const { data: profile, error } = await supabase
-        .from('users')
-        .select('*')
-        .eq('id', userId)
-        .single<DbUser>();
+    const result = await this.wrapAsync(
+      'getUserById',
+      async () => {
+        const { data: profile, error } = await supabase
+          .from('users')
+          .select('*')
+          .eq('id', userId)
+          .single<DbUser>();
 
-      if (error || !profile) {
-        return null;
-      }
+        if (error || !profile) {
+          return null;
+        }
 
-      return this.transformDbUserToUser(profile);
-    } catch (error) {
-      SecureLogger.error('Failed to get user by ID', {
-        code: 'USER_009',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return null;
-    }
+        return this.transformDbUserToUser(profile);
+      },
+      { userId },
+    );
+
+    return result.success && result.data ? result.data : null;
   }
 
   async getUserByEmail(email: string): Promise<User | null> {
-    try {
-      const { data: profile, error } = await supabase
-        .from('users')
-        .select('*')
-        .eq('email', email.toLowerCase())
-        .single<DbUser>();
+    const result = await this.wrapAsync(
+      'getUserByEmail',
+      async () => {
+        const { data: profile, error } = await supabase
+          .from('users')
+          .select('*')
+          .eq('email', email.toLowerCase())
+          .single<DbUser>();
 
-      if (error || !profile) {
-        return null;
-      }
+        if (error || !profile) {
+          return null;
+        }
 
-      return this.transformDbUserToUser(profile);
-    } catch (error) {
-      SecureLogger.error('Failed to get user by email', {
-        code: 'USER_010',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return null;
-    }
+        return this.transformDbUserToUser(profile);
+      },
+      { email },
+    );
+
+    return result.success && result.data ? result.data : null;
   }
 
   async logout(): Promise<boolean> {
-    try {
+    const result = await this.wrapAsync('logout', async () => {
       // Clear cache
       this.currentUserCache = null;
       this.cacheTimestamp = 0;
@@ -311,17 +297,13 @@ class UserStorageService implements IUserStorageService {
 
       // Note: Actual Supabase logout is handled by AuthService
       return true;
-    } catch (error) {
-      SecureLogger.error('Failed to complete logout operation', {
-        code: 'USER_011',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+    });
+
+    return result.success && result.data ? result.data : false;
   }
 
   async saveUserToken(token: string): Promise<boolean> {
-    try {
+    const result = await this.wrapAsync('saveUserToken', async () => {
       // In Supabase, tokens are managed by the auth service
       // Store in SecureStore for compatibility
       await SecureStore.setItemAsync('user_token', token, {
@@ -329,17 +311,13 @@ class UserStorageService implements IUserStorageService {
         authenticationPrompt: 'Authenticate to save token',
       });
       return true;
-    } catch (error) {
-      SecureLogger.error('Failed to save user token', {
-        code: 'USER_012',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+    });
+
+    return result.success && result.data ? result.data : false;
   }
 
   async getUserToken(): Promise<string | null> {
-    try {
+    const result = await this.wrapAsync('getUserToken', async () => {
       // Try to get token from Supabase session first
       const {
         data: { session },
@@ -349,36 +327,24 @@ class UserStorageService implements IUserStorageService {
       }
 
       // Fall back to SecureStore for compatibility
-      return await SecureStore.getItemAsync('user_token');
-    } catch (error) {
-      SecureLogger.error('Failed to retrieve user token', {
-        code: 'USER_013',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return null;
-    }
+      return SecureStore.getItemAsync('user_token');
+    });
+
+    return result.success && result.data ? result.data : null;
   }
 
   async clearAllUsers(): Promise<boolean> {
-    try {
+    const result = await this.wrapAsync('clearAllUsers', async () => {
       // In Supabase context, we don't clear all users
       // Just clear local cache and token
       this.currentUserCache = null;
       this.cacheTimestamp = 0;
       await SecureStore.deleteItemAsync('user_token').catch(() => {});
 
-      SecureLogger.info('Local user data cleared', {
-        code: 'USER_014',
-      });
-
       return true;
-    } catch (error) {
-      SecureLogger.error('Failed to clear user data', {
-        code: 'USER_015',
-        context: error instanceof Error ? error.message : 'Unknown error',
-      });
-      return false;
-    }
+    });
+
+    return result.success && result.data ? result.data : false;
   }
 
   // Helper method to transform database user to User type
@@ -431,58 +397,58 @@ class UserStorageService implements IUserStorageService {
 
   subscribeToUserUpdates(userId: string, callback: (user: User) => void): Promise<() => void> {
     return new Promise((resolve) => {
-      try {
-        // Create channel for user updates
-        const channel = supabase
-          .channel(`user:${userId}`)
-          .on(
-            'postgres_changes',
-            {
-              event: 'UPDATE',
-              schema: 'public',
-              table: 'users',
-              filter: `id=eq.${userId}`,
-            },
-            (payload: RealtimePostgresChangesPayload<DbUser>) => {
-              if (payload.new) {
-                const updatedUser = this.transformDbUserToUser(payload.new as DbUser);
-
-                // Update cache if it's the current user
-                if (this.currentUserCache?.id === userId) {
-                  this.currentUserCache = updatedUser;
-                  this.cacheTimestamp = Date.now();
+      const result = this.wrapSync(
+        'subscribeToUserUpdates',
+        () => {
+          // Create channel for user updates
+          const channel = supabase
+            .channel(`user:${userId}`)
+            .on(
+              'postgres_changes',
+              {
+                event: 'UPDATE',
+                schema: 'public',
+                table: 'users',
+                filter: `id=eq.${userId}`,
+              },
+              (payload: RealtimePostgresChangesPayload<DbUser>) => {
+                if (payload.new) {
+                  const updatedUser = this.transformDbUserToUser(payload.new as DbUser);
+
+                  // Update cache if it's the current user
+                  if (this.currentUserCache?.id === userId) {
+                    this.currentUserCache = updatedUser;
+                    this.cacheTimestamp = Date.now();
+                  }
+
+                  // Notify callback
+                  callback(updatedUser);
                 }
+              },
+            )
+            .subscribe();
+
+          // Store subscription
+          this.subscriptions.set(userId, channel);
+
+          // Return unsubscribe function
+          return () => {
+            const sub = this.subscriptions.get(userId);
+            if (sub) {
+              void sub.unsubscribe();
+              this.subscriptions.delete(userId);
+            }
+          };
+        },
+        { userId },
+      );
 
-                // Notify callback
-                callback(updatedUser);
-              }
-            },
-          )
-          .subscribe();
-
-        // Store subscription
-        this.subscriptions.set(userId, channel);
-
-        // Return unsubscribe function
-        resolve(() => {
-          const sub = this.subscriptions.get(userId);
-          if (sub) {
-            void sub.unsubscribe();
-            this.subscriptions.delete(userId);
-          }
-        });
-      } catch (error) {
-        SecureLogger.error('Failed to subscribe to user updates', {
-          code: 'USER_016',
-          context: error instanceof Error ? error.message : 'Unknown error',
-        });
-
-        // Return no-op unsubscribe function
-        resolve(() => {});
-      }
+      // Return the unsubscribe function or a no-op function on error
+      resolve(result.success && result.data ? result.data : () => {});
     });
   }
 }
 
-// Export singleton instance
+// Export both class and singleton instance
+export { UserStorageService };
 export default new UserStorageService();
diff --git a/src/services/__tests__/AuthService.test.js b/src/services/__tests__/AuthService.test.js
index 8556595..b596f92 100644
--- a/src/services/__tests__/AuthService.test.js
+++ b/src/services/__tests__/AuthService.test.js
@@ -1,8 +1,7 @@
 // ABOUTME: Tests for AuthService authentication functionality
 
-import AuthService from '../AuthService';
-import CryptoService from '../CryptoService';
-import UserStorageService from '../UserStorageService';
+import { AuthService } from '../AuthService';
+// Service imports for type definitions only
 import * as SecureStore from 'expo-secure-store';
 import { createUser, updateUser } from '../../utils/UserModel';
 import { USER_ROLE } from '../../constants/UserConstants';
@@ -10,6 +9,7 @@ import { USER_ROLE } from '../../constants/UserConstants';
 // Mock dependencies
 jest.mock('../CryptoService');
 jest.mock('../UserStorageService');
+jest.mock('../RateLimiter');
 jest.mock('../../utils/UserModel', () => ({
   ...jest.requireActual('../../utils/UserModel'),
   createUser: jest.fn(),
@@ -21,39 +21,54 @@ jest.mock('expo-secure-store', () => ({
 }));
 
 describe('AuthService', () => {
+  let authService;
+  let mockCryptoService;
+  let mockUserStorageService;
+  let mockRateLimiter;
+
   beforeEach(() => {
     jest.clearAllMocks();
 
-    // Default mock implementations
-    CryptoService.generateSalt.mockResolvedValue('mocksalt');
-    CryptoService.hashPassword.mockResolvedValue('mockhash');
-    CryptoService.generateSessionToken.mockResolvedValue('mocktoken.1234567890');
-    CryptoService.verifyPassword.mockResolvedValue(true);
-    CryptoService.isTokenExpired.mockReturnValue(false);
-    CryptoService.parseSessionToken.mockReturnValue({
-      token: 'mocktoken',
-      timestamp: 1234567890,
-      isValid: true,
-    });
-    CryptoService.generateToken.mockResolvedValue('reference-token');
-    CryptoService.generateSecureBytes.mockResolvedValue(new Uint8Array(32));
-    CryptoService.encrypt.mockResolvedValue('encrypted-token');
-    CryptoService.decrypt.mockResolvedValue('reference-token');
-    CryptoService.hash.mockResolvedValue('token-fingerprint');
+    // Create mock service instances
+    mockCryptoService = {
+      generateSalt: jest.fn().mockResolvedValue('mocksalt'),
+      hashPassword: jest.fn().mockResolvedValue('mockhash'),
+      generateSessionToken: jest.fn().mockResolvedValue('mocktoken.1234567890'),
+      verifyPassword: jest.fn().mockResolvedValue(true),
+      isTokenExpired: jest.fn().mockReturnValue(false),
+      parseSessionToken: jest.fn().mockReturnValue({
+        token: 'mocktoken',
+        timestamp: 1234567890,
+        isValid: true,
+      }),
+      generateToken: jest.fn().mockResolvedValue('reference-token'),
+      generateSecureBytes: jest.fn().mockResolvedValue(new Uint8Array(32)),
+      encrypt: jest.fn().mockResolvedValue('encrypted-token'),
+      decrypt: jest.fn().mockResolvedValue('reference-token'),
+      hash: jest.fn().mockResolvedValue('token-fingerprint'),
+    };
+
+    mockUserStorageService = {
+      getUserByEmail: jest.fn().mockResolvedValue(null),
+      saveUser: jest.fn().mockResolvedValue(true),
+      updateUser: jest.fn().mockResolvedValue(true),
+      setCurrentUser: jest.fn().mockResolvedValue(true),
+      saveUserToken: jest.fn().mockResolvedValue(true),
+      getCurrentUser: jest.fn().mockResolvedValue(null),
+      getUserToken: jest.fn().mockResolvedValue(null),
+      logout: jest.fn().mockResolvedValue(true),
+    };
+
+    mockRateLimiter = {
+      canAttemptLogin: jest.fn().mockReturnValue(true),
+      getLockoutEndTime: jest.fn().mockReturnValue(null),
+      recordLoginAttempt: jest.fn(),
+    };
 
     // SecureStore mocks
     SecureStore.getItemAsync.mockResolvedValue(null);
     SecureStore.setItemAsync.mockResolvedValue(undefined);
 
-    UserStorageService.getUserByEmail.mockResolvedValue(null);
-    UserStorageService.saveUser.mockResolvedValue(true);
-    UserStorageService.updateUser.mockResolvedValue(true);
-    UserStorageService.setCurrentUser.mockResolvedValue(true);
-    UserStorageService.saveUserToken.mockResolvedValue(true);
-    UserStorageService.getCurrentUser.mockResolvedValue(null);
-    UserStorageService.getUserToken.mockResolvedValue(null);
-    UserStorageService.logout.mockResolvedValue(true);
-
     createUser.mockImplementation((data) => ({
       id: 'user_123',
       email: data.email,
@@ -72,47 +87,50 @@ describe('AuthService', () => {
       ...updates,
       updatedAt: new Date(),
     }));
+
+    // Create AuthService instance with mocked dependencies
+    authService = new AuthService(mockCryptoService, mockUserStorageService, mockRateLimiter);
   });
 
   describe('validatePassword', () => {
     it('should validate a strong password', () => {
-      const result = AuthService.validatePassword('Test123!@#');
+      const result = authService.validatePassword('Test123!@#');
       expect(result.isValid).toBe(true);
       expect(result.errors).toHaveLength(0);
     });
 
     it('should reject short passwords', () => {
-      const result = AuthService.validatePassword('Test1!');
+      const result = authService.validatePassword('Test1!');
       expect(result.isValid).toBe(false);
       expect(result.errors).toContain('Password must be at least 8 characters long');
     });
 
     it('should require uppercase letter', () => {
-      const result = AuthService.validatePassword('test123!@#');
+      const result = authService.validatePassword('test123!@#');
       expect(result.isValid).toBe(false);
       expect(result.errors).toContain('Password must contain at least one uppercase letter');
     });
 
     it('should require lowercase letter', () => {
-      const result = AuthService.validatePassword('TEST123!@#');
+      const result = authService.validatePassword('TEST123!@#');
       expect(result.isValid).toBe(false);
       expect(result.errors).toContain('Password must contain at least one lowercase letter');
     });
 
     it('should require number', () => {
-      const result = AuthService.validatePassword('TestTest!@#');
+      const result = authService.validatePassword('TestTest!@#');
       expect(result.isValid).toBe(false);
       expect(result.errors).toContain('Password must contain at least one number');
     });
 
     it('should require special character', () => {
-      const result = AuthService.validatePassword('TestTest123');
+      const result = authService.validatePassword('TestTest123');
       expect(result.isValid).toBe(false);
       expect(result.errors).toContain('Password must contain at least one special character');
     });
 
     it('should reject empty password', () => {
-      const result = AuthService.validatePassword('');
+      const result = authService.validatePassword('');
       expect(result.isValid).toBe(false);
       expect(result.errors).toContain('Password is required');
     });
@@ -120,7 +138,7 @@ describe('AuthService', () => {
 
   describe('signUp', () => {
     it('should successfully sign up a new user', async () => {
-      const result = await AuthService.signUp(
+      const result = await authService.signUp(
         'test@example.com',
         'Test123!@#',
         'Test User',
@@ -131,15 +149,15 @@ describe('AuthService', () => {
       expect(result.user).toBeDefined();
       expect(result.token).toBe('reference-token');
 
-      expect(CryptoService.generateSalt).toHaveBeenCalled();
-      expect(CryptoService.hashPassword).toHaveBeenCalledWith('Test123!@#', 'mocksalt');
-      expect(UserStorageService.saveUser).toHaveBeenCalled();
-      expect(UserStorageService.setCurrentUser).toHaveBeenCalled();
-      expect(UserStorageService.saveUserToken).toHaveBeenCalledWith('reference-token');
+      expect(mockCryptoService.generateSalt).toHaveBeenCalled();
+      expect(mockCryptoService.hashPassword).toHaveBeenCalledWith('Test123!@#', 'mocksalt');
+      expect(mockUserStorageService.saveUser).toHaveBeenCalled();
+      expect(mockUserStorageService.setCurrentUser).toHaveBeenCalled();
+      expect(mockUserStorageService.saveUserToken).toHaveBeenCalledWith('reference-token');
     });
 
     it('should reject invalid email', async () => {
-      const result = await AuthService.signUp(
+      const result = await authService.signUp(
         'invalid-email',
         'Test123!@#',
         'Test User',
@@ -151,9 +169,9 @@ describe('AuthService', () => {
     });
 
     it('should reject existing user', async () => {
-      UserStorageService.getUserByEmail.mockResolvedValue({ id: 'existing_user' });
+      mockUserStorageService.getUserByEmail.mockResolvedValue({ id: 'existing_user' });
 
-      const result = await AuthService.signUp(
+      const result = await authService.signUp(
         'existing@example.com',
         'Test123!@#',
         'Test User',
@@ -165,7 +183,7 @@ describe('AuthService', () => {
     });
 
     it('should reject weak password', async () => {
-      const result = await AuthService.signUp(
+      const result = await authService.signUp(
         'test@example.com',
         'weak',
         'Test User',
@@ -177,7 +195,7 @@ describe('AuthService', () => {
     });
 
     it('should sanitize user data in response', async () => {
-      const result = await AuthService.signUp(
+      const result = await authService.signUp(
         'test@example.com',
         'Test123!@#',
         'Test User',
@@ -202,59 +220,59 @@ describe('AuthService', () => {
     };
 
     beforeEach(() => {
-      UserStorageService.getUserByEmail.mockResolvedValue(mockUser);
+      mockUserStorageService.getUserByEmail.mockResolvedValue(mockUser);
     });
 
     it('should successfully login with correct credentials', async () => {
-      const result = await AuthService.login('test@example.com', 'Test123!@#');
+      const result = await authService.login('test@example.com', 'Test123!@#');
 
       expect(result.success).toBe(true);
       expect(result.user).toBeDefined();
       expect(result.token).toBe('reference-token');
 
-      expect(CryptoService.verifyPassword).toHaveBeenCalledWith(
+      expect(mockCryptoService.verifyPassword).toHaveBeenCalledWith(
         'Test123!@#',
         'existinghash',
         'existingsalt',
       );
-      expect(UserStorageService.updateUser).toHaveBeenCalled();
-      expect(UserStorageService.setCurrentUser).toHaveBeenCalled();
-      expect(UserStorageService.saveUserToken).toHaveBeenCalledWith('reference-token');
+      expect(mockUserStorageService.updateUser).toHaveBeenCalled();
+      expect(mockUserStorageService.setCurrentUser).toHaveBeenCalled();
+      expect(mockUserStorageService.saveUserToken).toHaveBeenCalledWith('reference-token');
     });
 
     it('should reject missing credentials', async () => {
-      const result = await AuthService.login('', '');
+      const result = await authService.login('', '');
 
       expect(result.success).toBe(false);
       expect(result.error).toBe('Email and password are required');
     });
 
     it('should reject non-existent user', async () => {
-      UserStorageService.getUserByEmail.mockResolvedValue(null);
+      mockUserStorageService.getUserByEmail.mockResolvedValue(null);
 
-      const result = await AuthService.login('nonexistent@example.com', 'Test123!@#');
+      const result = await authService.login('nonexistent@example.com', 'Test123!@#');
 
       expect(result.success).toBe(false);
       expect(result.error).toBe('Invalid email or password');
     });
 
     it('should reject incorrect password', async () => {
-      CryptoService.verifyPassword.mockResolvedValue(false);
+      mockCryptoService.verifyPassword.mockResolvedValue(false);
 
-      const result = await AuthService.login('test@example.com', 'WrongPassword');
+      const result = await authService.login('test@example.com', 'WrongPassword');
 
       expect(result.success).toBe(false);
       expect(result.error).toBe('Invalid email or password');
     });
 
     it('should handle users without password (migration needed)', async () => {
-      UserStorageService.getUserByEmail.mockResolvedValue({
+      mockUserStorageService.getUserByEmail.mockResolvedValue({
         ...mockUser,
         passwordHash: null,
         passwordSalt: null,
       });
 
-      const result = await AuthService.login('test@example.com', 'Test123!@#');
+      const result = await authService.login('test@example.com', 'Test123!@#');
 
       expect(result.success).toBe(false);
       expect(result.error).toBe('Invalid email or password');
@@ -268,8 +286,8 @@ describe('AuthService', () => {
         sessionToken: null, // No longer stored in user
       };
 
-      UserStorageService.getUserToken.mockResolvedValue('reference-token');
-      UserStorageService.getCurrentUser.mockResolvedValue(mockUser);
+      mockUserStorageService.getUserToken.mockResolvedValue('reference-token');
+      mockUserStorageService.getCurrentUser.mockResolvedValue(mockUser);
 
       // Mock secure token retrieval
       const mockSecureToken = {
@@ -293,17 +311,17 @@ describe('AuthService', () => {
         return Promise.resolve(null);
       });
 
-      const result = await AuthService.verifySession();
+      const result = await authService.verifySession();
 
       expect(result.isValid).toBe(true);
       expect(result.user).toBeDefined();
-      expect(UserStorageService.updateUser).toHaveBeenCalled();
+      expect(mockUserStorageService.updateUser).toHaveBeenCalled();
     });
 
     it('should reject missing token', async () => {
-      UserStorageService.getUserToken.mockResolvedValue(null);
+      mockUserStorageService.getUserToken.mockResolvedValue(null);
 
-      const result = await AuthService.verifySession();
+      const result = await authService.verifySession();
 
       expect(result.isValid).toBe(false);
       expect(result.reason).toBe('No session token');
@@ -315,8 +333,8 @@ describe('AuthService', () => {
         sessionToken: null,
       };
 
-      UserStorageService.getUserToken.mockResolvedValue('reference-token');
-      UserStorageService.getCurrentUser.mockResolvedValue(mockUser);
+      mockUserStorageService.getUserToken.mockResolvedValue('reference-token');
+      mockUserStorageService.getCurrentUser.mockResolvedValue(mockUser);
 
       // Mock expired secure token
       const expiredToken = {
@@ -337,11 +355,11 @@ describe('AuthService', () => {
         return Promise.resolve(null);
       });
 
-      const result = await AuthService.verifySession();
+      const result = await authService.verifySession();
 
       expect(result.isValid).toBe(false);
       expect(result.reason).toBe('Invalid or expired token');
-      expect(UserStorageService.logout).toHaveBeenCalled();
+      expect(mockUserStorageService.logout).toHaveBeenCalled();
     });
 
     it('should reject mismatched token', async () => {
@@ -350,8 +368,8 @@ describe('AuthService', () => {
         sessionToken: null,
       };
 
-      UserStorageService.getUserToken.mockResolvedValue('reference-token');
-      UserStorageService.getCurrentUser.mockResolvedValue(mockUser);
+      mockUserStorageService.getUserToken.mockResolvedValue('reference-token');
+      mockUserStorageService.getCurrentUser.mockResolvedValue(mockUser);
 
       // Mock secure token with different device
       const mismatchedToken = {
@@ -372,11 +390,11 @@ describe('AuthService', () => {
         return Promise.resolve(null);
       });
 
-      const result = await AuthService.verifySession();
+      const result = await authService.verifySession();
 
       expect(result.isValid).toBe(false);
       expect(result.reason).toBe('Token used from different device');
-      expect(UserStorageService.logout).toHaveBeenCalled();
+      expect(mockUserStorageService.logout).toHaveBeenCalled();
     });
   });
 
@@ -387,23 +405,23 @@ describe('AuthService', () => {
         sessionToken: 'mocktoken',
       };
 
-      UserStorageService.getCurrentUser.mockResolvedValue(mockUser);
+      mockUserStorageService.getCurrentUser.mockResolvedValue(mockUser);
 
-      const result = await AuthService.logout();
+      const result = await authService.logout();
 
       expect(result.success).toBe(true);
       expect(updateUser).toHaveBeenCalledWith(mockUser, { sessionToken: null });
-      expect(UserStorageService.updateUser).toHaveBeenCalled();
-      expect(UserStorageService.logout).toHaveBeenCalled();
+      expect(mockUserStorageService.updateUser).toHaveBeenCalled();
+      expect(mockUserStorageService.logout).toHaveBeenCalled();
     });
 
     it('should handle logout when no user', async () => {
-      UserStorageService.getCurrentUser.mockResolvedValue(null);
+      mockUserStorageService.getCurrentUser.mockResolvedValue(null);
 
-      const result = await AuthService.logout();
+      const result = await authService.logout();
 
       expect(result.success).toBe(true);
-      expect(UserStorageService.logout).toHaveBeenCalled();
+      expect(mockUserStorageService.logout).toHaveBeenCalled();
     });
   });
 
@@ -415,43 +433,43 @@ describe('AuthService', () => {
     };
 
     beforeEach(() => {
-      UserStorageService.getCurrentUser.mockResolvedValue(mockUser);
+      mockUserStorageService.getCurrentUser.mockResolvedValue(mockUser);
     });
 
     it('should successfully change password', async () => {
-      const result = await AuthService.changePassword('OldPass123!', 'NewPass456!');
+      const result = await authService.changePassword('OldPass123!', 'NewPass456!');
 
       expect(result.success).toBe(true);
-      expect(CryptoService.verifyPassword).toHaveBeenCalledWith(
+      expect(mockCryptoService.verifyPassword).toHaveBeenCalledWith(
         'OldPass123!',
         'oldhash',
         'oldsalt',
       );
-      expect(CryptoService.generateSalt).toHaveBeenCalled();
-      expect(CryptoService.hashPassword).toHaveBeenCalledWith('NewPass456!', 'mocksalt');
-      expect(UserStorageService.updateUser).toHaveBeenCalled();
+      expect(mockCryptoService.generateSalt).toHaveBeenCalled();
+      expect(mockCryptoService.hashPassword).toHaveBeenCalledWith('NewPass456!', 'mocksalt');
+      expect(mockUserStorageService.updateUser).toHaveBeenCalled();
     });
 
     it('should reject incorrect current password', async () => {
-      CryptoService.verifyPassword.mockResolvedValue(false);
+      mockCryptoService.verifyPassword.mockResolvedValue(false);
 
-      const result = await AuthService.changePassword('WrongPass123!', 'NewPass456!');
+      const result = await authService.changePassword('WrongPass123!', 'NewPass456!');
 
       expect(result.success).toBe(false);
       expect(result.error).toBe('Current password is incorrect');
     });
 
     it('should reject weak new password', async () => {
-      const result = await AuthService.changePassword('OldPass123!', 'weak');
+      const result = await authService.changePassword('OldPass123!', 'weak');
 
       expect(result.success).toBe(false);
       expect(result.error).toContain('Password must be at least');
     });
 
     it('should reject when no user logged in', async () => {
-      UserStorageService.getCurrentUser.mockResolvedValue(null);
+      mockUserStorageService.getCurrentUser.mockResolvedValue(null);
 
-      const result = await AuthService.changePassword('OldPass123!', 'NewPass456!');
+      const result = await authService.changePassword('OldPass123!', 'NewPass456!');
 
       expect(result.success).toBe(false);
       expect(result.error).toBe('No user logged in');
@@ -465,9 +483,9 @@ describe('AuthService', () => {
         email: 'test@example.com',
       };
 
-      UserStorageService.getUserByEmail.mockResolvedValue(mockUser);
+      mockUserStorageService.getUserByEmail.mockResolvedValue(mockUser);
 
-      const result = await AuthService.resetPassword('test@example.com', 'NewPass123!');
+      const result = await authService.resetPassword('test@example.com', 'NewPass123!');
 
       expect(result.success).toBe(true);
       expect(result.message).toBe('If an account exists, the password has been reset');
@@ -482,13 +500,13 @@ describe('AuthService', () => {
     });
 
     it('should not reveal if user exists', async () => {
-      UserStorageService.getUserByEmail.mockResolvedValue(null);
+      mockUserStorageService.getUserByEmail.mockResolvedValue(null);
 
-      const result = await AuthService.resetPassword('nonexistent@example.com', 'NewPass123!');
+      const result = await authService.resetPassword('nonexistent@example.com', 'NewPass123!');
 
       expect(result.success).toBe(true);
       expect(result.message).toBe('If an account exists, the password has been reset');
-      expect(UserStorageService.updateUser).not.toHaveBeenCalled();
+      expect(mockUserStorageService.updateUser).not.toHaveBeenCalled();
     });
 
     it('should reject weak password', async () => {
@@ -497,9 +515,9 @@ describe('AuthService', () => {
         email: 'test@example.com',
       };
 
-      UserStorageService.getUserByEmail.mockResolvedValue(mockUser);
+      mockUserStorageService.getUserByEmail.mockResolvedValue(mockUser);
 
-      const result = await AuthService.resetPassword('test@example.com', 'weak');
+      const result = await authService.resetPassword('test@example.com', 'weak');
 
       expect(result.success).toBe(false);
       expect(result.error).toContain('Password must be at least');
@@ -518,7 +536,7 @@ describe('AuthService', () => {
         role: USER_ROLE.ADHD_USER,
       };
 
-      const sanitized = AuthService.sanitizeUser(user);
+      const sanitized = authService.sanitizeUser(user);
 
       expect(sanitized.id).toBe('user_123');
       expect(sanitized.email).toBe('test@example.com');
diff --git a/src/services/__tests__/BiometricAuthService.test.js b/src/services/__tests__/BiometricAuthService.test.js
index 4261e07..a7d808a 100644
--- a/src/services/__tests__/BiometricAuthService.test.js
+++ b/src/services/__tests__/BiometricAuthService.test.js
@@ -2,8 +2,10 @@
 // including Face ID, Touch ID, and PIN fallback functionality
 
 import * as LocalAuthentication from 'expo-local-authentication';
-import { BiometricAuthService } from '../BiometricAuthService';
-import { SecureStorageService } from '../SecureStorageService';
+
+// Import the actual class for testing
+const BiometricAuthServiceModule = jest.requireActual('../BiometricAuthService');
+const { BiometricAuthService } = BiometricAuthServiceModule;
 
 // Mock dependencies
 jest.mock('expo-local-authentication', () => ({
@@ -18,17 +20,54 @@ jest.mock('expo-local-authentication', () => ({
   },
 }));
 
+// Create mock functions
+const mockSaveSecure = jest.fn();
+const mockGetSecure = jest.fn();
+const mockDeleteSecure = jest.fn();
+
 jest.mock('../SecureStorageService', () => ({
-  SecureStorageService: {
-    saveSecure: jest.fn(),
-    getSecure: jest.fn(),
-    deleteSecure: jest.fn(),
+  default: {
+    saveSecure: mockSaveSecure,
+    getSecure: mockGetSecure,
+    deleteSecure: mockDeleteSecure,
+  },
+}));
+
+// Mock BaseService to avoid complex inheritance issues in tests
+jest.mock('../BaseService', () => ({
+  BaseService: class {
+    constructor(serviceName) {
+      this.serviceName = serviceName;
+      this.logger = { info: jest.fn(), warn: jest.fn(), error: jest.fn() };
+    }
+
+    async wrapAsync(_operation, fn, _context) {
+      try {
+        const data = await fn();
+        return { success: true, data };
+      } catch (error) {
+        return { success: false, error: { message: error.message } };
+      }
+    }
+
+    logError(_operation, _error) {
+      // Mock implementation
+    }
   },
 }));
 
 describe('BiometricAuthService', () => {
+  let biometricAuthService;
+
   beforeEach(() => {
     jest.clearAllMocks();
+    // Create a new instance for each test with mocked dependencies
+    const mockSecureStorageService = {
+      saveSecure: mockSaveSecure,
+      getSecure: mockGetSecure,
+      deleteSecure: mockDeleteSecure,
+    };
+    biometricAuthService = new BiometricAuthService(mockSecureStorageService);
   });
 
   describe('checkBiometricSupport', () => {
@@ -39,7 +78,7 @@ describe('BiometricAuthService', () => {
       ]);
       LocalAuthentication.isEnrolledAsync.mockResolvedValue(true);
 
-      const support = await BiometricAuthService.checkBiometricSupport();
+      const support = await biometricAuthService.checkBiometricSupport();
 
       expect(support).toEqual({
         hasHardware: true,
@@ -56,7 +95,7 @@ describe('BiometricAuthService', () => {
       ]);
       LocalAuthentication.isEnrolledAsync.mockResolvedValue(true);
 
-      const support = await BiometricAuthService.checkBiometricSupport();
+      const support = await biometricAuthService.checkBiometricSupport();
 
       expect(support.biometricType).toBe('fingerprint');
     });
@@ -68,7 +107,7 @@ describe('BiometricAuthService', () => {
       ]);
       LocalAuthentication.isEnrolledAsync.mockResolvedValue(true);
 
-      const support = await BiometricAuthService.checkBiometricSupport();
+      const support = await biometricAuthService.checkBiometricSupport();
 
       expect(support.biometricType).toBe('iris');
     });
@@ -78,7 +117,7 @@ describe('BiometricAuthService', () => {
       LocalAuthentication.supportedAuthenticationTypesAsync.mockResolvedValue([]);
       LocalAuthentication.isEnrolledAsync.mockResolvedValue(false);
 
-      const support = await BiometricAuthService.checkBiometricSupport();
+      const support = await biometricAuthService.checkBiometricSupport();
 
       expect(support.biometricType).toBe('none');
     });
@@ -89,9 +128,9 @@ describe('BiometricAuthService', () => {
       LocalAuthentication.authenticateAsync.mockResolvedValue({
         success: true,
       });
-      SecureStorageService.saveSecure.mockResolvedValue();
+      mockSaveSecure.mockResolvedValue();
 
-      const result = await BiometricAuthService.authenticate();
+      const result = await biometricAuthService.authenticate();
 
       expect(LocalAuthentication.authenticateAsync).toHaveBeenCalledWith({
         promptMessage: 'Authenticate to access your ADHD Todo data',
@@ -100,10 +139,7 @@ describe('BiometricAuthService', () => {
         disableDeviceFallback: false,
       });
       expect(result).toEqual({ success: true });
-      expect(SecureStorageService.saveSecure).toHaveBeenCalledWith(
-        'LAST_AUTH_SUCCESS',
-        expect.any(String),
-      );
+      expect(mockSaveSecure).toHaveBeenCalledWith('LAST_AUTH_SUCCESS', expect.any(String));
     });
 
     it('should use custom prompt message when provided', async () => {
@@ -111,7 +147,7 @@ describe('BiometricAuthService', () => {
         success: true,
       });
 
-      await BiometricAuthService.authenticate('Access medication data');
+      await biometricAuthService.authenticate('Access medication data');
 
       expect(LocalAuthentication.authenticateAsync).toHaveBeenCalledWith(
         expect.objectContaining({
@@ -127,24 +163,24 @@ describe('BiometricAuthService', () => {
         warning: 'User cancelled authentication',
       });
 
-      const result = await BiometricAuthService.authenticate();
+      const result = await biometricAuthService.authenticate();
 
       expect(result).toEqual({
         success: false,
         error: 'user_cancel',
         warning: 'User cancelled authentication',
       });
-      expect(SecureStorageService.saveSecure).not.toHaveBeenCalled();
+      expect(mockSaveSecure).not.toHaveBeenCalled();
     });
 
     it('should handle authentication exceptions', async () => {
       LocalAuthentication.authenticateAsync.mockRejectedValue(new Error('Hardware error'));
 
-      const result = await BiometricAuthService.authenticate();
+      const result = await biometricAuthService.authenticate();
 
       expect(result).toEqual({
         success: false,
-        error: 'Authentication failed',
+        error: 'Hardware error',
       });
     });
   });
@@ -158,55 +194,46 @@ describe('BiometricAuthService', () => {
     };
 
     it('should save security settings', async () => {
-      SecureStorageService.saveSecure.mockResolvedValue();
+      mockSaveSecure.mockResolvedValue();
 
-      await BiometricAuthService.setupAppSecurity(mockSettings);
+      await biometricAuthService.setupAppSecurity(mockSettings);
 
-      expect(SecureStorageService.saveSecure).toHaveBeenCalledWith(
-        'SECURITY_SETTINGS',
-        mockSettings,
-      );
+      expect(mockSaveSecure).toHaveBeenCalledWith('SECURITY_SETTINGS', mockSettings);
     });
 
     it('should enable launch authentication when required', async () => {
-      SecureStorageService.saveSecure.mockResolvedValue();
+      mockSaveSecure.mockResolvedValue();
 
-      await BiometricAuthService.setupAppSecurity({
+      await biometricAuthService.setupAppSecurity({
         ...mockSettings,
         requireAuthOnLaunch: true,
       });
 
-      expect(SecureStorageService.saveSecure).toHaveBeenCalledWith('LAUNCH_AUTH_ENABLED', true);
+      expect(mockSaveSecure).toHaveBeenCalledWith('LAUNCH_AUTH_ENABLED', true);
     });
 
     it('should enable sensitive data protection when required', async () => {
-      SecureStorageService.saveSecure.mockResolvedValue();
+      mockSaveSecure.mockResolvedValue();
 
-      await BiometricAuthService.setupAppSecurity({
+      await biometricAuthService.setupAppSecurity({
         ...mockSettings,
         sensitiveDataAuth: true,
       });
 
-      expect(SecureStorageService.saveSecure).toHaveBeenCalledWith(
-        'SENSITIVE_DATA_AUTH_ENABLED',
-        true,
-      );
+      expect(mockSaveSecure).toHaveBeenCalledWith('SENSITIVE_DATA_AUTH_ENABLED', true);
     });
 
     it('should not enable features when disabled in settings', async () => {
-      SecureStorageService.saveSecure.mockResolvedValue();
+      mockSaveSecure.mockResolvedValue();
 
-      await BiometricAuthService.setupAppSecurity({
+      await biometricAuthService.setupAppSecurity({
         ...mockSettings,
         requireAuthOnLaunch: false,
         sensitiveDataAuth: false,
       });
 
-      expect(SecureStorageService.saveSecure).toHaveBeenCalledTimes(1);
-      expect(SecureStorageService.saveSecure).toHaveBeenCalledWith(
-        'SECURITY_SETTINGS',
-        expect.any(Object),
-      );
+      expect(mockSaveSecure).toHaveBeenCalledTimes(1);
+      expect(mockSaveSecure).toHaveBeenCalledWith('SECURITY_SETTINGS', expect.any(Object));
     });
   });
 
@@ -218,18 +245,18 @@ describe('BiometricAuthService', () => {
         autoLockTimeout: 300000,
         maxFailedAttempts: 3,
       };
-      SecureStorageService.getSecure.mockResolvedValue(mockSettings);
+      mockGetSecure.mockResolvedValue(mockSettings);
 
-      const settings = await BiometricAuthService.getSecuritySettings();
+      const settings = await biometricAuthService.getSecuritySettings();
 
       expect(settings).toEqual(mockSettings);
-      expect(SecureStorageService.getSecure).toHaveBeenCalledWith('SECURITY_SETTINGS');
+      expect(mockGetSecure).toHaveBeenCalledWith('SECURITY_SETTINGS');
     });
 
     it('should return default settings when none saved', async () => {
-      SecureStorageService.getSecure.mockResolvedValue(null);
+      mockGetSecure.mockResolvedValue(null);
 
-      const settings = await BiometricAuthService.getSecuritySettings();
+      const settings = await biometricAuthService.getSecuritySettings();
 
       expect(settings).toEqual({
         requireAuthOnLaunch: false,
@@ -242,63 +269,63 @@ describe('BiometricAuthService', () => {
 
   describe('recordFailedAttempt', () => {
     it('should increment failed attempt counter', async () => {
-      SecureStorageService.getSecure.mockResolvedValue(2);
-      SecureStorageService.saveSecure.mockResolvedValue();
+      mockGetSecure.mockResolvedValue(2);
+      mockSaveSecure.mockResolvedValue();
 
-      const count = await BiometricAuthService.recordFailedAttempt();
+      const count = await biometricAuthService.recordFailedAttempt();
 
       expect(count).toBe(3);
-      expect(SecureStorageService.saveSecure).toHaveBeenCalledWith('FAILED_AUTH_ATTEMPTS', 3);
+      expect(mockSaveSecure).toHaveBeenCalledWith('FAILED_AUTH_ATTEMPTS', 3);
     });
 
     it('should start counter at 1 for first failure', async () => {
-      SecureStorageService.getSecure.mockResolvedValue(null);
-      SecureStorageService.saveSecure.mockResolvedValue();
+      mockGetSecure.mockResolvedValue(null);
+      mockSaveSecure.mockResolvedValue();
 
-      const count = await BiometricAuthService.recordFailedAttempt();
+      const count = await biometricAuthService.recordFailedAttempt();
 
       expect(count).toBe(1);
-      expect(SecureStorageService.saveSecure).toHaveBeenCalledWith('FAILED_AUTH_ATTEMPTS', 1);
+      expect(mockSaveSecure).toHaveBeenCalledWith('FAILED_AUTH_ATTEMPTS', 1);
     });
   });
 
   describe('resetFailedAttempts', () => {
     it('should delete failed attempt counter', async () => {
-      SecureStorageService.deleteSecure.mockResolvedValue();
+      mockDeleteSecure.mockResolvedValue();
 
-      await BiometricAuthService.resetFailedAttempts();
+      await biometricAuthService.resetFailedAttempts();
 
-      expect(SecureStorageService.deleteSecure).toHaveBeenCalledWith('FAILED_AUTH_ATTEMPTS');
+      expect(mockDeleteSecure).toHaveBeenCalledWith('FAILED_AUTH_ATTEMPTS');
     });
   });
 
   describe('checkIfLocked', () => {
     it('should return true when max attempts exceeded', async () => {
-      SecureStorageService.getSecure
+      mockGetSecure
         .mockResolvedValueOnce(5) // failed attempts
         .mockResolvedValueOnce({ maxFailedAttempts: 3 }); // settings
 
-      const isLocked = await BiometricAuthService.checkIfLocked();
+      const isLocked = await biometricAuthService.checkIfLocked();
 
       expect(isLocked).toBe(true);
     });
 
     it('should return false when under max attempts', async () => {
-      SecureStorageService.getSecure
+      mockGetSecure
         .mockResolvedValueOnce(2) // failed attempts
         .mockResolvedValueOnce({ maxFailedAttempts: 5 }); // settings
 
-      const isLocked = await BiometricAuthService.checkIfLocked();
+      const isLocked = await biometricAuthService.checkIfLocked();
 
       expect(isLocked).toBe(false);
     });
 
     it('should return false when no failed attempts', async () => {
-      SecureStorageService.getSecure
+      mockGetSecure
         .mockResolvedValueOnce(null) // no failed attempts
         .mockResolvedValueOnce({ maxFailedAttempts: 3 }); // settings
 
-      const isLocked = await BiometricAuthService.checkIfLocked();
+      const isLocked = await biometricAuthService.checkIfLocked();
 
       expect(isLocked).toBe(false);
     });
diff --git a/src/services/__tests__/NotificationService.supabase.test.js b/src/services/__tests__/NotificationService.supabase.test.js
index 489ba3c..dd27042 100644
--- a/src/services/__tests__/NotificationService.supabase.test.js
+++ b/src/services/__tests__/NotificationService.supabase.test.js
@@ -83,7 +83,8 @@ describe('NotificationService - Supabase Implementation', () => {
         { taskId: 'task-123', taskTitle: 'Test Task' },
       );
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
       expect(supabase.from).toHaveBeenCalledWith('notifications');
       expect(mockQueryBuilder.insert).toHaveBeenCalledWith(
         expect.objectContaining({
@@ -111,7 +112,8 @@ describe('NotificationService - Supabase Implementation', () => {
         {},
       );
 
-      expect(result).toBe(false);
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
     });
   });
 
@@ -149,7 +151,8 @@ describe('NotificationService - Supabase Implementation', () => {
 
       const result = await notificationService.notifyTaskAssigned(mockTask, mockAssigner);
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
       expect(mockQueryBuilder.insert).toHaveBeenCalledWith(
         expect.objectContaining({
           user_id: 'partner-456',
@@ -172,7 +175,8 @@ describe('NotificationService - Supabase Implementation', () => {
 
       const result = await notificationService.notifyTaskStarted(mockTask, mockStartedByUser);
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
       expect(mockQueryBuilder.insert).toHaveBeenCalledWith(
         expect.objectContaining({
           user_id: 'assigner-123', // Notify the assigner
@@ -195,7 +199,8 @@ describe('NotificationService - Supabase Implementation', () => {
 
       const result = await notificationService.notifyTaskCompleted(mockTask, mockCompletedByUser);
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
       expect(mockQueryBuilder.insert).toHaveBeenCalledWith(
         expect.objectContaining({
           user_id: 'assigner-123', // Notify the assigner
@@ -218,7 +223,8 @@ describe('NotificationService - Supabase Implementation', () => {
 
       const result = await notificationService.notifyTaskOverdue(mockTask);
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
       expect(mockQueryBuilder.insert).toHaveBeenCalledWith(
         expect.objectContaining({
           type: NotificationTypes.TASK_OVERDUE,
@@ -230,12 +236,18 @@ describe('NotificationService - Supabase Implementation', () => {
 
   describe('Encouragement and check-in', () => {
     beforeEach(() => {
-      // Mock UserStorageService.getUserById to return user data
+      // Mock UserStorageService.getUserById to return user data in Result<T> format
       UserStorageService.getUserById = jest.fn().mockImplementation((userId) => {
         if (userId === mockUser.id) {
-          return Promise.resolve(createMockUser({ id: mockUser.id, name: 'Test User' }));
+          return Promise.resolve({
+            success: true,
+            data: createMockUser({ id: mockUser.id, name: 'Test User' }),
+          });
         }
-        return Promise.resolve(null);
+        return Promise.resolve({
+          success: true,
+          data: null,
+        });
       });
     });
 
@@ -254,7 +266,8 @@ describe('NotificationService - Supabase Implementation', () => {
         'task-123',
       );
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
       expect(mockQueryBuilder.insert).toHaveBeenCalledWith(
         expect.objectContaining({
           user_id: mockPartner.id,
@@ -282,7 +295,8 @@ describe('NotificationService - Supabase Implementation', () => {
         'How are you doing?',
       );
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
       expect(mockQueryBuilder.insert).toHaveBeenCalledWith(
         expect.objectContaining({
           user_id: mockPartner.id,
@@ -325,7 +339,7 @@ describe('NotificationService - Supabase Implementation', () => {
       });
       supabase.from.mockReturnValue(mockQueryBuilder);
 
-      const notifications = await notificationService.getNotificationsForUser(mockUser.id);
+      const result = await notificationService.getNotificationsForUser(mockUser.id);
 
       expect(supabase.from).toHaveBeenCalledWith('notifications');
       expect(mockQueryBuilder.select).toHaveBeenCalledWith('*');
@@ -333,9 +347,10 @@ describe('NotificationService - Supabase Implementation', () => {
       expect(mockQueryBuilder.order).toHaveBeenCalledWith('created_at', { ascending: false });
       expect(mockQueryBuilder.limit).toHaveBeenCalledWith(100);
 
-      expect(notifications).toHaveLength(2);
-      expect(notifications[0].type).toBe(NotificationTypes.TASK_ASSIGNED);
-      expect(notifications[1].type).toBe(NotificationTypes.ENCOURAGEMENT);
+      expect(result.success).toBe(true);
+      expect(result.data).toHaveLength(2);
+      expect(result.data[0].type).toBe(NotificationTypes.TASK_ASSIGNED);
+      expect(result.data[1].type).toBe(NotificationTypes.ENCOURAGEMENT);
     });
 
     it('should return empty array on error', async () => {
@@ -346,8 +361,9 @@ describe('NotificationService - Supabase Implementation', () => {
       });
       supabase.from.mockReturnValue(mockQueryBuilder);
 
-      const notifications = await notificationService.getNotificationsForUser(mockUser.id);
-      expect(notifications).toEqual([]);
+      const result = await notificationService.getNotificationsForUser(mockUser.id);
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
     });
   });
 
@@ -366,11 +382,12 @@ describe('NotificationService - Supabase Implementation', () => {
       });
       supabase.from.mockReturnValue(mockQueryBuilder);
 
-      const count = await notificationService.getUnreadNotificationCount(mockUser.id);
+      const result = await notificationService.getUnreadNotificationCount(mockUser.id);
 
       expect(mockQueryBuilder.eq).toHaveBeenCalledWith('user_id', mockUser.id);
       expect(mockQueryBuilder.is).toHaveBeenCalledWith('read', false);
-      expect(count).toBe(2);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(2);
     });
   });
 
@@ -392,7 +409,8 @@ describe('NotificationService - Supabase Implementation', () => {
 
       const result = await notificationService.markNotificationAsRead(notificationId);
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
       expect(mockQueryBuilder.update).toHaveBeenCalledWith({
         read: true,
         read_at: expect.any(String),
@@ -412,7 +430,8 @@ describe('NotificationService - Supabase Implementation', () => {
 
       const result = await notificationService.markAllNotificationsAsRead(mockUser.id);
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
       expect(mockQueryBuilder.update).toHaveBeenCalledWith({
         read: true,
         read_at: expect.any(String),
@@ -433,7 +452,8 @@ describe('NotificationService - Supabase Implementation', () => {
 
       const result = await notificationService.clearNotificationsForUser(mockUser.id);
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
       expect(mockQueryBuilder.delete).toHaveBeenCalled();
       expect(mockQueryBuilder.eq).toHaveBeenCalledWith('user_id', mockUser.id);
     });
@@ -447,7 +467,8 @@ describe('NotificationService - Supabase Implementation', () => {
       supabase.from.mockReturnValue(mockQueryBuilder);
 
       const result = await notificationService.clearNotificationsForUser(mockUser.id);
-      expect(result).toBe(false);
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
     });
   });
 
diff --git a/src/services/__tests__/NotificationService.test.js b/src/services/__tests__/NotificationService.test.js
deleted file mode 100644
index f40e352..0000000
--- a/src/services/__tests__/NotificationService.test.js
+++ /dev/null
@@ -1,961 +0,0 @@
-// ABOUTME: Comprehensive unit tests for NotificationService
-// Tests notification sending, preferences, and storage functionality
-
-import AsyncStorage from '@react-native-async-storage/async-storage';
-import NotificationService from '../NotificationService';
-import UserStorageService from '../UserStorageService';
-import SecureLogger from '../SecureLogger';
-import { NOTIFICATION_TYPES, NOTIFICATION_PREFERENCES } from '../../constants/UserConstants';
-
-// Mock dependencies
-jest.mock('@react-native-async-storage/async-storage');
-jest.mock('../UserStorageService');
-jest.mock('../SecureLogger');
-
-describe('NotificationService', () => {
-  const mockUser = {
-    id: 'user_123',
-    name: 'Test User',
-    notificationPreferences: {
-      global: NOTIFICATION_PREFERENCES.ALL,
-      taskAssigned: true,
-      taskStarted: true,
-      taskCompleted: true,
-      taskOverdue: true,
-      encouragement: true,
-      checkIn: true,
-    },
-  };
-
-  const mockPartnerUser = {
-    id: 'partner_456',
-    name: 'Partner User',
-    notificationPreferences: {
-      global: NOTIFICATION_PREFERENCES.ALL,
-    },
-  };
-
-  beforeEach(() => {
-    jest.clearAllMocks();
-
-    // Reset NotificationService state
-    NotificationService.pendingNotifications = [];
-
-    // Default mock implementations
-    AsyncStorage.getItem.mockResolvedValue(null);
-    AsyncStorage.setItem.mockResolvedValue();
-    UserStorageService.getUserById.mockResolvedValue(mockUser);
-  });
-
-  afterAll(() => {
-    // Stop the cleanup job to prevent Jest from hanging
-    NotificationService.stopCleanupJob();
-  });
-
-  describe('loadNotifications', () => {
-    it('should load notifications from AsyncStorage on initialization', async () => {
-      const storedNotifications = [
-        { id: 'notif_1', toUserId: 'user_123', type: 'task_assigned', read: false },
-        { id: 'notif_2', toUserId: 'user_123', type: 'task_completed', read: true },
-      ];
-
-      AsyncStorage.getItem.mockResolvedValue(JSON.stringify(storedNotifications));
-
-      await NotificationService.loadNotifications();
-
-      expect(AsyncStorage.getItem).toHaveBeenCalledWith('@adhdtodo:notifications');
-      expect(NotificationService.pendingNotifications).toEqual(storedNotifications);
-    });
-
-    it('should handle empty storage gracefully', async () => {
-      AsyncStorage.getItem.mockResolvedValue(null);
-
-      await NotificationService.loadNotifications();
-
-      expect(NotificationService.pendingNotifications).toEqual([]);
-    });
-
-    it('should handle storage errors gracefully', async () => {
-      AsyncStorage.getItem.mockRejectedValue(new Error('Storage error'));
-
-      await NotificationService.loadNotifications();
-
-      expect(SecureLogger.error).toHaveBeenCalledWith('Failed to load notifications from storage', {
-        code: 'NOTIF_LOAD_001',
-      });
-      expect(NotificationService.pendingNotifications).toEqual([]);
-    });
-  });
-
-  describe('saveNotifications', () => {
-    it('should save notifications to AsyncStorage', async () => {
-      NotificationService.pendingNotifications = [
-        { id: 'notif_1', toUserId: 'user_123', type: 'task_assigned' },
-        { id: 'notif_2', toUserId: 'user_456', type: 'task_completed' },
-      ];
-
-      await NotificationService.saveNotifications();
-
-      expect(AsyncStorage.setItem).toHaveBeenCalledWith(
-        '@adhdtodo:notifications',
-        JSON.stringify(NotificationService.pendingNotifications),
-      );
-    });
-
-    it('should limit saved notifications to MAX_NOTIFICATIONS', async () => {
-      // Create more than MAX_NOTIFICATIONS
-      const notifications = [];
-      for (let i = 0; i < NotificationService.MAX_NOTIFICATIONS + 10; i++) {
-        notifications.push({
-          id: `notif_${i}`,
-          toUserId: 'user_123',
-          type: 'task_assigned',
-        });
-      }
-      NotificationService.pendingNotifications = notifications;
-
-      await NotificationService.saveNotifications();
-
-      const savedData = JSON.parse(AsyncStorage.setItem.mock.calls[0][1]);
-      expect(savedData.length).toBe(NotificationService.MAX_NOTIFICATIONS);
-      expect(savedData[0].id).toBe('notif_10'); // Should keep most recent
-    });
-
-    it('should handle save errors gracefully', async () => {
-      AsyncStorage.setItem.mockRejectedValue(new Error('Save error'));
-
-      NotificationService.pendingNotifications = [{ id: 'notif_1' }];
-      await NotificationService.saveNotifications();
-
-      expect(SecureLogger.error).toHaveBeenCalledWith('Failed to save notifications to storage', {
-        code: 'NOTIF_SAVE_001',
-      });
-    });
-  });
-
-  describe('sendNotification', () => {
-    it('should send notification successfully', async () => {
-      const result = await NotificationService.sendNotification(
-        'user_123',
-        NOTIFICATION_TYPES.TASK_ASSIGNED,
-        { taskTitle: 'Test Task' },
-      );
-
-      expect(result).toBe(true);
-      expect(UserStorageService.getUserById).toHaveBeenCalledWith('user_123');
-      expect(NotificationService.pendingNotifications.length).toBe(1);
-
-      const notification = NotificationService.pendingNotifications[0];
-      expect(notification).toMatchObject({
-        toUserId: 'user_123',
-        type: NOTIFICATION_TYPES.TASK_ASSIGNED,
-        data: { taskTitle: 'Test Task' },
-        read: false,
-      });
-      expect(notification.id).toMatch(/^notif_\d+_[a-z0-9]+$/);
-      expect(notification.timestamp).toBeInstanceOf(Date);
-
-      expect(AsyncStorage.setItem).toHaveBeenCalled();
-    });
-
-    it('should return false if user not found', async () => {
-      UserStorageService.getUserById.mockResolvedValue(null);
-
-      const result = await NotificationService.sendNotification(
-        'unknown_user',
-        NOTIFICATION_TYPES.TASK_ASSIGNED,
-        {},
-      );
-
-      expect(result).toBe(false);
-      expect(NotificationService.pendingNotifications.length).toBe(0);
-    });
-
-    it('should respect user notification preferences', async () => {
-      const silentUser = {
-        ...mockUser,
-        notificationPreferences: {
-          global: NOTIFICATION_PREFERENCES.SILENT,
-        },
-      };
-      UserStorageService.getUserById.mockResolvedValue(silentUser);
-
-      const result = await NotificationService.sendNotification(
-        'user_123',
-        NOTIFICATION_TYPES.TASK_ASSIGNED,
-        {},
-      );
-
-      expect(result).toBe(false);
-      expect(NotificationService.pendingNotifications.length).toBe(0);
-    });
-
-    it('should handle errors gracefully and log them', async () => {
-      const mockError = new Error('Database error');
-      UserStorageService.getUserById.mockRejectedValue(mockError);
-
-      const result = await NotificationService.sendNotification(
-        'user_123',
-        NOTIFICATION_TYPES.TASK_ASSIGNED,
-        { taskTitle: 'Test Task' },
-      );
-
-      expect(result).toBe(false);
-      expect(NotificationService.pendingNotifications.length).toBe(0);
-      expect(SecureLogger.error).toHaveBeenCalledWith('Failed to send notification', {
-        code: 'NOTIF_SEND_001',
-        context: 'Database error - User: user_123, Type: ' + NOTIFICATION_TYPES.TASK_ASSIGNED,
-      });
-    });
-  });
-
-  describe('shouldSendNotification', () => {
-    it('should return false for silent global preference', () => {
-      const user = {
-        notificationPreferences: { global: NOTIFICATION_PREFERENCES.SILENT },
-      };
-
-      const result = NotificationService.shouldSendNotification(
-        user,
-        NOTIFICATION_TYPES.TASK_ASSIGNED,
-      );
-      expect(result).toBe(false);
-    });
-
-    it('should only allow critical notifications for important_only preference', () => {
-      const user = {
-        notificationPreferences: { global: NOTIFICATION_PREFERENCES.IMPORTANT_ONLY },
-      };
-
-      expect(
-        NotificationService.shouldSendNotification(user, NOTIFICATION_TYPES.TASK_OVERDUE),
-      ).toBe(true);
-      expect(
-        NotificationService.shouldSendNotification(
-          user,
-          NOTIFICATION_TYPES.DEADLINE_CHANGE_REQUEST,
-        ),
-      ).toBe(true);
-      expect(
-        NotificationService.shouldSendNotification(user, NOTIFICATION_TYPES.TASK_ASSIGNED),
-      ).toBe(false);
-      expect(
-        NotificationService.shouldSendNotification(user, NOTIFICATION_TYPES.ENCOURAGEMENT),
-      ).toBe(false);
-    });
-
-    it('should respect specific notification type preferences', () => {
-      const user = {
-        notificationPreferences: {
-          global: NOTIFICATION_PREFERENCES.ALL,
-          taskAssigned: false,
-          taskStarted: true,
-          taskCompleted: false,
-          taskOverdue: true,
-          encouragement: false,
-          checkIn: true,
-        },
-      };
-
-      expect(
-        NotificationService.shouldSendNotification(user, NOTIFICATION_TYPES.TASK_ASSIGNED),
-      ).toBe(false);
-      expect(
-        NotificationService.shouldSendNotification(user, NOTIFICATION_TYPES.TASK_STARTED),
-      ).toBe(true);
-      expect(
-        NotificationService.shouldSendNotification(user, NOTIFICATION_TYPES.TASK_COMPLETED),
-      ).toBe(false);
-      expect(
-        NotificationService.shouldSendNotification(user, NOTIFICATION_TYPES.TASK_OVERDUE),
-      ).toBe(true);
-      expect(
-        NotificationService.shouldSendNotification(user, NOTIFICATION_TYPES.ENCOURAGEMENT),
-      ).toBe(false);
-      expect(NotificationService.shouldSendNotification(user, NOTIFICATION_TYPES.CHECK_IN)).toBe(
-        true,
-      );
-    });
-
-    it('should default to true for unknown notification types', () => {
-      const user = {
-        notificationPreferences: { global: NOTIFICATION_PREFERENCES.ALL },
-      };
-
-      const result = NotificationService.shouldSendNotification(user, 'unknown_type');
-      expect(result).toBe(true);
-    });
-  });
-
-  describe('Task notification methods', () => {
-    const mockTask = {
-      id: 'task_123',
-      title: 'Test Task',
-      assignedTo: 'user_123',
-      assignedBy: 'partner_456',
-      dueDate: new Date('2024-12-31'),
-      priority: 'high',
-      startedAt: new Date(),
-      completedAt: new Date(),
-      timeSpent: 3600,
-      xpEarned: 50,
-    };
-
-    describe('notifyTaskAssigned', () => {
-      it('should send task assigned notification', async () => {
-        const result = await NotificationService.notifyTaskAssigned(mockTask, mockPartnerUser);
-
-        expect(result).toBe(true);
-        expect(NotificationService.pendingNotifications[0]).toMatchObject({
-          toUserId: 'user_123',
-          type: NOTIFICATION_TYPES.TASK_ASSIGNED,
-          data: {
-            taskId: 'task_123',
-            taskTitle: 'Test Task',
-            assignedBy: 'Partner User',
-            dueDate: mockTask.dueDate,
-            priority: 'high',
-          },
-        });
-      });
-    });
-
-    describe('notifyTaskStarted', () => {
-      it('should send task started notification to assigner', async () => {
-        const result = await NotificationService.notifyTaskStarted(mockTask, mockUser);
-
-        expect(result).toBe(true);
-        expect(NotificationService.pendingNotifications[0]).toMatchObject({
-          toUserId: 'partner_456',
-          type: NOTIFICATION_TYPES.TASK_STARTED,
-          data: {
-            taskId: 'task_123',
-            taskTitle: 'Test Task',
-            startedBy: 'Test User',
-            startedAt: mockTask.startedAt,
-          },
-        });
-      });
-
-      it('should return false if task has no assignedBy', async () => {
-        const taskWithoutAssigner = { ...mockTask, assignedBy: null };
-        const result = await NotificationService.notifyTaskStarted(taskWithoutAssigner, mockUser);
-
-        expect(result).toBe(false);
-        expect(NotificationService.pendingNotifications.length).toBe(0);
-      });
-
-      it('should return false if startedByUser is null', async () => {
-        const result = await NotificationService.notifyTaskStarted(mockTask, null);
-
-        expect(result).toBe(false);
-        expect(NotificationService.pendingNotifications.length).toBe(0);
-      });
-
-      it('should return false if startedByUser has no name', async () => {
-        const userWithoutName = { ...mockUser, name: undefined };
-        const result = await NotificationService.notifyTaskStarted(mockTask, userWithoutName);
-
-        expect(result).toBe(false);
-        expect(NotificationService.pendingNotifications.length).toBe(0);
-      });
-    });
-
-    describe('notifyTaskCompleted', () => {
-      it('should send task completed notification', async () => {
-        const result = await NotificationService.notifyTaskCompleted(mockTask, mockUser);
-
-        expect(result).toBe(true);
-        expect(NotificationService.pendingNotifications[0]).toMatchObject({
-          toUserId: 'partner_456',
-          type: NOTIFICATION_TYPES.TASK_COMPLETED,
-          data: {
-            taskId: 'task_123',
-            taskTitle: 'Test Task',
-            completedBy: 'Test User',
-            completedAt: mockTask.completedAt,
-            timeSpent: 3600,
-            xpEarned: 50,
-          },
-        });
-      });
-
-      it('should return false if task has no assignedBy', async () => {
-        const taskWithoutAssigner = { ...mockTask, assignedBy: null };
-        const result = await NotificationService.notifyTaskCompleted(taskWithoutAssigner, mockUser);
-
-        expect(result).toBe(false);
-      });
-
-      it('should return false if completedByUser is null', async () => {
-        const result = await NotificationService.notifyTaskCompleted(mockTask, null);
-
-        expect(result).toBe(false);
-        expect(NotificationService.pendingNotifications.length).toBe(0);
-      });
-
-      it('should return false if completedByUser has no name', async () => {
-        const userWithoutName = { ...mockUser, name: undefined };
-        const result = await NotificationService.notifyTaskCompleted(mockTask, userWithoutName);
-
-        expect(result).toBe(false);
-        expect(NotificationService.pendingNotifications.length).toBe(0);
-      });
-    });
-
-    describe('notifyTaskOverdue', () => {
-      it('should send task overdue notification', async () => {
-        const result = await NotificationService.notifyTaskOverdue(mockTask);
-
-        expect(result).toBe(true);
-        expect(NotificationService.pendingNotifications[0]).toMatchObject({
-          toUserId: 'partner_456',
-          type: NOTIFICATION_TYPES.TASK_OVERDUE,
-          data: {
-            taskId: 'task_123',
-            taskTitle: 'Test Task',
-            dueDate: mockTask.dueDate,
-          },
-        });
-      });
-
-      it('should return false if task has no assignedBy', async () => {
-        const taskWithoutAssigner = { ...mockTask, assignedBy: null };
-        const result = await NotificationService.notifyTaskOverdue(taskWithoutAssigner);
-
-        expect(result).toBe(false);
-      });
-    });
-  });
-
-  describe('Social notification methods', () => {
-    beforeEach(() => {
-      UserStorageService.getUserById
-        .mockResolvedValueOnce(mockUser) // For fromUser lookup
-        .mockResolvedValueOnce(mockPartnerUser); // For toUser lookup
-    });
-
-    describe('sendEncouragement', () => {
-      it('should send encouragement notification', async () => {
-        const result = await NotificationService.sendEncouragement(
-          'user_123',
-          'partner_456',
-          'You can do it!',
-          'task_123',
-        );
-
-        expect(result).toBe(true);
-        expect(NotificationService.pendingNotifications[0]).toMatchObject({
-          toUserId: 'partner_456',
-          type: NOTIFICATION_TYPES.ENCOURAGEMENT,
-          data: {
-            message: 'You can do it!',
-            fromUser: 'Test User',
-            taskId: 'task_123',
-          },
-        });
-      });
-
-      it('should send encouragement without taskId', async () => {
-        const result = await NotificationService.sendEncouragement(
-          'user_123',
-          'partner_456',
-          'Keep going!',
-        );
-
-        expect(result).toBe(true);
-        expect(NotificationService.pendingNotifications[0].data.taskId).toBe(null);
-      });
-
-      it('should return false if fromUser not found', async () => {
-        UserStorageService.getUserById.mockReset();
-        UserStorageService.getUserById.mockResolvedValue(null);
-
-        const result = await NotificationService.sendEncouragement(
-          'unknown_user',
-          'partner_456',
-          'Message',
-        );
-
-        expect(result).toBe(false);
-      });
-    });
-
-    describe('sendCheckIn', () => {
-      it('should send check-in notification', async () => {
-        const result = await NotificationService.sendCheckIn(
-          'user_123',
-          'partner_456',
-          'How are you doing today?',
-        );
-
-        expect(result).toBe(true);
-        expect(NotificationService.pendingNotifications[0]).toMatchObject({
-          toUserId: 'partner_456',
-          type: NOTIFICATION_TYPES.CHECK_IN,
-          data: {
-            message: 'How are you doing today?',
-            fromUser: 'Test User',
-          },
-        });
-      });
-
-      it('should return false if fromUser not found', async () => {
-        UserStorageService.getUserById.mockReset();
-        UserStorageService.getUserById.mockResolvedValue(null);
-
-        const result = await NotificationService.sendCheckIn(
-          'unknown_user',
-          'partner_456',
-          'Message',
-        );
-
-        expect(result).toBe(false);
-      });
-    });
-  });
-
-  describe('Notification retrieval and management', () => {
-    beforeEach(() => {
-      const now = new Date();
-      NotificationService.pendingNotifications = [
-        {
-          id: 'notif_1',
-          toUserId: 'user_123',
-          type: 'task_assigned',
-          read: false,
-          timestamp: now,
-          data: {},
-        },
-        {
-          id: 'notif_2',
-          toUserId: 'user_123',
-          type: 'task_completed',
-          read: true,
-          timestamp: new Date(now.getTime() - 60000),
-          data: {},
-        },
-        {
-          id: 'notif_3',
-          toUserId: 'partner_456',
-          type: 'encouragement',
-          read: false,
-          timestamp: new Date(now.getTime() - 120000),
-          data: {},
-        },
-        {
-          id: 'notif_4',
-          toUserId: 'user_123',
-          type: 'check_in',
-          read: false,
-          timestamp: new Date(now.getTime() - 180000),
-          data: {},
-        },
-      ];
-    });
-
-    describe('getNotificationsForUser', () => {
-      it('should return notifications for specific user', async () => {
-        const notifications = await NotificationService.getNotificationsForUser('user_123');
-
-        expect(notifications.length).toBe(3);
-        expect(notifications.every((n) => n.toUserId === 'user_123')).toBe(true);
-      });
-
-      it('should return empty array for user with no notifications', async () => {
-        const notifications = await NotificationService.getNotificationsForUser('unknown_user');
-
-        expect(notifications).toEqual([]);
-      });
-    });
-
-    describe('getUnreadNotificationCount', () => {
-      it('should return count of unread notifications', async () => {
-        const count = await NotificationService.getUnreadNotificationCount('user_123');
-
-        expect(count).toBe(2); // notif_1 and notif_4 are unread
-      });
-
-      it('should return 0 for user with no notifications', async () => {
-        const count = await NotificationService.getUnreadNotificationCount('unknown_user');
-
-        expect(count).toBe(0);
-      });
-    });
-
-    describe('markNotificationAsRead', () => {
-      it('should mark notification as read', async () => {
-        const result = await NotificationService.markNotificationAsRead('notif_1');
-
-        expect(result).toBe(true);
-        expect(NotificationService.pendingNotifications[0].read).toBe(true);
-        expect(AsyncStorage.setItem).toHaveBeenCalled();
-      });
-
-      it('should return false for non-existent notification', async () => {
-        const result = await NotificationService.markNotificationAsRead('notif_999');
-
-        expect(result).toBe(false);
-      });
-    });
-
-    describe('markAllNotificationsAsRead', () => {
-      it('should mark all user notifications as read', async () => {
-        const result = await NotificationService.markAllNotificationsAsRead('user_123');
-
-        expect(result).toBe(true);
-
-        const userNotifications = NotificationService.pendingNotifications.filter(
-          (n) => n.toUserId === 'user_123',
-        );
-        expect(userNotifications.every((n) => n.read === true)).toBe(true);
-
-        // Partner notification should remain unread
-        const partnerNotification = NotificationService.pendingNotifications.find(
-          (n) => n.toUserId === 'partner_456',
-        );
-        expect(partnerNotification.read).toBe(false);
-
-        expect(AsyncStorage.setItem).toHaveBeenCalled();
-      });
-    });
-
-    describe('clearNotificationsForUser', () => {
-      it('should remove all notifications for user', async () => {
-        const result = await NotificationService.clearNotificationsForUser('user_123');
-
-        expect(result).toBe(true);
-        expect(NotificationService.pendingNotifications.length).toBe(1);
-        expect(NotificationService.pendingNotifications[0].toUserId).toBe('partner_456');
-        expect(AsyncStorage.setItem).toHaveBeenCalled();
-      });
-
-      it('should handle clearing for user with no notifications', async () => {
-        const result = await NotificationService.clearNotificationsForUser('unknown_user');
-
-        expect(result).toBe(true);
-        expect(NotificationService.pendingNotifications.length).toBe(4); // Unchanged
-      });
-    });
-  });
-
-  describe('Memory Leak Prevention', () => {
-    describe('cleanupOldNotifications', () => {
-      it('should remove notifications older than TTL_DAYS', async () => {
-        const now = new Date();
-        const oldDate = new Date();
-        oldDate.setDate(oldDate.getDate() - 31); // 31 days old
-        const recentDate = new Date();
-        recentDate.setDate(recentDate.getDate() - 10); // 10 days old
-
-        NotificationService.pendingNotifications = [
-          {
-            id: 'old_1',
-            toUserId: 'user_123',
-            type: 'task_assigned',
-            timestamp: oldDate,
-            read: false,
-            data: {},
-          },
-          {
-            id: 'old_2',
-            toUserId: 'user_123',
-            type: 'task_completed',
-            timestamp: oldDate,
-            read: true,
-            data: {},
-          },
-          {
-            id: 'recent_1',
-            toUserId: 'user_123',
-            type: 'encouragement',
-            timestamp: recentDate,
-            read: false,
-            data: {},
-          },
-          {
-            id: 'current_1',
-            toUserId: 'user_123',
-            type: 'check_in',
-            timestamp: now,
-            read: false,
-            data: {},
-          },
-        ];
-
-        await NotificationService.cleanupOldNotifications();
-
-        expect(NotificationService.pendingNotifications.length).toBe(2);
-        expect(
-          NotificationService.pendingNotifications.find((n) => n.id === 'old_1'),
-        ).toBeUndefined();
-        expect(
-          NotificationService.pendingNotifications.find((n) => n.id === 'old_2'),
-        ).toBeUndefined();
-        expect(
-          NotificationService.pendingNotifications.find((n) => n.id === 'recent_1'),
-        ).toBeDefined();
-        expect(
-          NotificationService.pendingNotifications.find((n) => n.id === 'current_1'),
-        ).toBeDefined();
-      });
-
-      it('should handle empty notification list', async () => {
-        NotificationService.pendingNotifications = [];
-        await NotificationService.cleanupOldNotifications();
-        expect(NotificationService.pendingNotifications).toEqual([]);
-      });
-    });
-
-    describe('Per-user notification limits', () => {
-      it('should enforce MAX_NOTIFICATIONS_PER_USER limit', async () => {
-        // Clear existing notifications
-        NotificationService.pendingNotifications = [];
-
-        // Mock user to always return valid user
-        UserStorageService.getUserById.mockResolvedValue(mockUser);
-
-        // Send MAX_NOTIFICATIONS_PER_USER notifications
-        for (let i = 0; i < NotificationService.MAX_NOTIFICATIONS_PER_USER; i++) {
-          await NotificationService.sendNotification('user_123', NOTIFICATION_TYPES.TASK_ASSIGNED, {
-            taskId: `task_${i}`,
-          });
-        }
-
-        expect(NotificationService.pendingNotifications.length).toBe(
-          NotificationService.MAX_NOTIFICATIONS_PER_USER,
-        );
-
-        // Send one more notification - should remove oldest
-        await NotificationService.sendNotification('user_123', NOTIFICATION_TYPES.TASK_ASSIGNED, {
-          taskId: 'task_new',
-        });
-
-        expect(NotificationService.pendingNotifications.length).toBe(
-          NotificationService.MAX_NOTIFICATIONS_PER_USER,
-        );
-        expect(NotificationService.pendingNotifications[0].data.taskId).toBe('task_1');
-        expect(
-          NotificationService.pendingNotifications[
-            NotificationService.MAX_NOTIFICATIONS_PER_USER - 1
-          ].data.taskId,
-        ).toBe('task_new');
-      });
-
-      it('should not affect other users notifications when enforcing per-user limit', async () => {
-        NotificationService.pendingNotifications = [];
-
-        // Setup different users
-        UserStorageService.getUserById
-          .mockResolvedValueOnce(mockUser)
-          .mockResolvedValueOnce(mockPartnerUser)
-          .mockResolvedValueOnce(mockUser);
-
-        // Add notifications for user_123
-        await NotificationService.sendNotification('user_123', NOTIFICATION_TYPES.TASK_ASSIGNED, {
-          taskId: 'user1_task',
-        });
-
-        // Add notification for partner_456
-        await NotificationService.sendNotification(
-          'partner_456',
-          NOTIFICATION_TYPES.TASK_ASSIGNED,
-          { taskId: 'partner_task' },
-        );
-
-        expect(NotificationService.pendingNotifications.length).toBe(2);
-
-        // Now fill up user_123's limit
-        UserStorageService.getUserById.mockResolvedValue(mockUser);
-        for (let i = 1; i < NotificationService.MAX_NOTIFICATIONS_PER_USER; i++) {
-          await NotificationService.sendNotification('user_123', NOTIFICATION_TYPES.TASK_ASSIGNED, {
-            taskId: `user1_task_${i}`,
-          });
-        }
-
-        // Send one more for user_123 - should only remove user_123's oldest
-        await NotificationService.sendNotification('user_123', NOTIFICATION_TYPES.TASK_ASSIGNED, {
-          taskId: 'user1_task_newest',
-        });
-
-        // Partner's notification should still exist
-        const partnerNotif = NotificationService.pendingNotifications.find(
-          (n) => n.toUserId === 'partner_456',
-        );
-        expect(partnerNotif).toBeDefined();
-        expect(partnerNotif.data.taskId).toBe('partner_task');
-      });
-    });
-
-    describe('Total notification limits', () => {
-      it('should trigger cleanup when MAX_TOTAL_NOTIFICATIONS is exceeded', async () => {
-        NotificationService.pendingNotifications = [];
-
-        // Create old notifications that should be cleaned up
-        const oldDate = new Date();
-        oldDate.setDate(oldDate.getDate() - 35);
-
-        // Add old notifications
-        for (let i = 0; i < 100; i++) {
-          NotificationService.pendingNotifications.push({
-            id: `old_${i}`,
-            toUserId: 'user_123',
-            type: 'task_assigned',
-            timestamp: oldDate,
-            read: false,
-            data: {},
-          });
-        }
-
-        // Add recent notifications up to MAX_TOTAL_NOTIFICATIONS
-        const now = new Date();
-        for (let i = 0; i < NotificationService.MAX_TOTAL_NOTIFICATIONS; i++) {
-          NotificationService.pendingNotifications.push({
-            id: `recent_${i}`,
-            toUserId: 'user_123',
-            type: 'task_assigned',
-            timestamp: now,
-            read: false,
-            data: {},
-          });
-        }
-
-        UserStorageService.getUserById.mockResolvedValue(mockUser);
-
-        // This should trigger cleanup
-        await NotificationService.sendNotification('user_123', NOTIFICATION_TYPES.TASK_ASSIGNED, {
-          taskId: 'trigger_cleanup',
-        });
-
-        // Should have removed old notifications
-        const oldNotifications = NotificationService.pendingNotifications.filter((n) =>
-          n.id.startsWith('old_'),
-        );
-        expect(oldNotifications.length).toBe(0);
-
-        // Recent notifications should remain
-        const recentNotifications = NotificationService.pendingNotifications.filter((n) =>
-          n.id.startsWith('recent_'),
-        );
-        expect(recentNotifications.length).toBeGreaterThan(0);
-      });
-    });
-
-    describe('Periodic cleanup job', () => {
-      beforeEach(() => {
-        jest.useFakeTimers();
-      });
-
-      afterEach(() => {
-        jest.useRealTimers();
-      });
-
-      it('should run cleanup job periodically', async () => {
-        // Spy on cleanupOldNotifications
-        const cleanupSpy = jest.spyOn(NotificationService, 'cleanupOldNotifications');
-        const saveSpy = jest.spyOn(NotificationService, 'saveNotifications');
-
-        // Start the cleanup job
-        NotificationService.startCleanupJob();
-
-        // Fast-forward time by 1 hour
-        jest.advanceTimersByTime(1000 * 60 * 60);
-
-        expect(cleanupSpy).toHaveBeenCalledTimes(1);
-        expect(saveSpy).toHaveBeenCalledTimes(1);
-
-        // Fast-forward another hour
-        jest.advanceTimersByTime(1000 * 60 * 60);
-
-        expect(cleanupSpy).toHaveBeenCalledTimes(2);
-        expect(saveSpy).toHaveBeenCalledTimes(2);
-
-        // Stop the cleanup job
-        NotificationService.stopCleanupJob();
-
-        cleanupSpy.mockRestore();
-        saveSpy.mockRestore();
-      });
-
-      it('should not run cleanup job if not started', () => {
-        const cleanupSpy = jest.spyOn(NotificationService, 'cleanupOldNotifications');
-
-        // Fast-forward time without starting the job
-        jest.advanceTimersByTime(1000 * 60 * 60 * 2);
-
-        expect(cleanupSpy).not.toHaveBeenCalled();
-
-        cleanupSpy.mockRestore();
-      });
-    });
-
-    describe('Performance with large notification counts', () => {
-      it('should handle large number of notifications efficiently', async () => {
-        NotificationService.pendingNotifications = [];
-
-        // Mock users for the test
-        UserStorageService.getUserById.mockImplementation(async (userId) => {
-          if (userId === 'user_123') return mockUser;
-          if (userId === 'partner_456') return mockPartnerUser;
-          return null;
-        });
-
-        // Create a realistic scenario - add notifications via the proper API
-        // Add old notifications for multiple users
-        const oldDate = new Date();
-        oldDate.setDate(oldDate.getDate() - 35); // Older than TTL
-
-        // First, add some old notifications that should be cleaned up
-        for (let i = 0; i < 100; i++) {
-          NotificationService.pendingNotifications.push({
-            id: `old_${i}`,
-            toUserId: i % 2 === 0 ? 'user_123' : 'partner_456',
-            type: 'task_assigned',
-            timestamp: oldDate,
-            read: false,
-            data: { index: i },
-          });
-        }
-
-        // Add notifications up to the limit to trigger cleanup
-        for (let i = 0; i < NotificationService.MAX_TOTAL_NOTIFICATIONS; i++) {
-          NotificationService.pendingNotifications.push({
-            id: `recent_${i}`,
-            toUserId: 'other_user_' + (i % 10),
-            type: 'task_assigned',
-            timestamp: new Date(),
-            read: false,
-            data: { index: i },
-          });
-        }
-
-        // Now send new notifications through the proper method
-        const startTime = Date.now();
-
-        // This should trigger cleanup of old notifications
-        await NotificationService.sendNotification('user_123', NOTIFICATION_TYPES.TASK_ASSIGNED, {
-          test: true,
-          trigger: 'cleanup',
-        });
-
-        const endTime = Date.now();
-        const timeTaken = endTime - startTime;
-
-        // Operation should complete quickly even with cleanup
-        expect(timeTaken).toBeLessThan(100);
-
-        // Old notifications should be cleaned up
-        const oldNotifications = NotificationService.pendingNotifications.filter((n) =>
-          n.id.startsWith('old_'),
-        );
-        expect(oldNotifications.length).toBe(0);
-
-        // Recent notifications should remain
-        const recentNotifications = NotificationService.pendingNotifications.filter((n) =>
-          n.id.startsWith('recent_'),
-        );
-        expect(recentNotifications.length).toBeGreaterThan(0);
-      });
-    });
-  });
-});
diff --git a/src/services/__tests__/PartnershipService.test.js b/src/services/__tests__/PartnershipService.test.js
index 66130f9..40de90a 100644
--- a/src/services/__tests__/PartnershipService.test.js
+++ b/src/services/__tests__/PartnershipService.test.js
@@ -1,8 +1,8 @@
-// ABOUTME: Comprehensive unit tests for PartnershipService
-// Tests partnership creation, invites, status updates, and partnership operations
+// ABOUTME: Comprehensive unit tests for PartnershipService with BaseService error handling
+// Tests partnership creation, invites, status updates, and partnership operations with Result<T> patterns
 
 import PartnershipService from '../PartnershipService';
-import SecureStorageService from '../SecureStorageService';
+import { supabase } from '../SupabaseService';
 import UserStorageService from '../UserStorageService';
 import {
   createPartnership,
@@ -13,8 +13,20 @@ import { setUserPartner } from '../../utils/UserModel';
 import { PARTNERSHIP_STATUS, USER_ROLE } from '../../constants/UserConstants';
 
 // Mock dependencies
-jest.mock('../SecureStorageService');
-jest.mock('../UserStorageService');
+jest.mock('../SupabaseService', () => ({
+  supabase: {
+    from: jest.fn(),
+    rpc: jest.fn(),
+    channel: jest.fn(),
+  },
+}));
+jest.mock('../UserStorageService', () => ({
+  __esModule: true,
+  default: {
+    getUserById: jest.fn(),
+    updateUser: jest.fn(),
+  },
+}));
 jest.mock('../../utils/PartnershipModel');
 jest.mock('../../utils/UserModel');
 
@@ -47,6 +59,21 @@ describe('PartnershipService', () => {
     terminatedAt: null,
   };
 
+  const mockDatabasePartnership = {
+    id: 'partnership_123',
+    adhd_user_id: 'user_123',
+    partner_id: 'partner_456',
+    status: 'active',
+    invite_code: 'ABC123',
+    invite_sent_by: 'user_123',
+    settings: mockPartnership.settings,
+    stats: mockPartnership.stats,
+    created_at: '2024-01-01T00:00:00.000Z',
+    updated_at: '2024-01-07T00:00:00.000Z',
+    accepted_at: '2024-01-02T00:00:00.000Z',
+    terminated_at: null,
+  };
+
   const mockPendingPartnership = {
     ...mockPartnership,
     id: 'partnership_pending',
@@ -63,7 +90,7 @@ describe('PartnershipService', () => {
     partnerId: 'partner_456',
   };
 
-  const mockPartner = {
+  const _mockPartner = {
     id: 'partner_456',
     name: 'Partner User',
     email: 'partner@example.com',
@@ -71,15 +98,36 @@ describe('PartnershipService', () => {
     partnerId: 'user_123',
   };
 
+  let mockSupabaseQuery;
+
   beforeEach(() => {
     jest.clearAllMocks();
 
+    // Mock Supabase query chain
+    mockSupabaseQuery = {
+      select: jest.fn().mockReturnThis(),
+      insert: jest.fn().mockReturnThis(),
+      update: jest.fn().mockReturnThis(),
+      delete: jest.fn().mockReturnThis(),
+      eq: jest.fn().mockReturnThis(),
+      or: jest.fn().mockReturnThis(),
+      neq: jest.fn().mockReturnThis(),
+      single: jest.fn().mockReturnThis(),
+    };
+
+    // Set default resolved values for common operations
+    mockSupabaseQuery.select.mockResolvedValue({ error: null, data: [] });
+    mockSupabaseQuery.insert.mockResolvedValue({ error: null });
+    mockSupabaseQuery.update.mockResolvedValue({ error: null });
+    mockSupabaseQuery.delete.mockResolvedValue({ error: null });
+    mockSupabaseQuery.single.mockResolvedValue({ error: null, data: null });
+
+    supabase.from.mockReturnValue(mockSupabaseQuery);
+    supabase.rpc.mockReturnValue({ error: null, data: 'INVITE123' });
+
     // Default mock implementations
-    SecureStorageService.getItem.mockResolvedValue(null);
-    SecureStorageService.setItem.mockResolvedValue();
-    SecureStorageService.removeItem.mockResolvedValue();
     UserStorageService.getUserById.mockResolvedValue(null);
-    UserStorageService.updateUser.mockResolvedValue(true);
+    UserStorageService.updateUser.mockResolvedValue({ success: true, data: true });
 
     // Mock partnership model functions
     createPartnership.mockImplementation((data) => ({
@@ -113,84 +161,91 @@ describe('PartnershipService', () => {
   });
 
   describe('getAllPartnerships', () => {
-    it('should return all partnerships from storage', async () => {
-      const partnerships = [mockPartnership, mockPendingPartnership];
-      SecureStorageService.getItem.mockResolvedValue(partnerships);
+    it('should return all partnerships from Supabase', async () => {
+      mockSupabaseQuery.select.mockResolvedValue({
+        error: null,
+        data: [mockDatabasePartnership],
+      });
 
       const result = await PartnershipService.getAllPartnerships();
 
-      expect(SecureStorageService.getItem).toHaveBeenCalledWith('partnerships');
-      expect(result).toEqual(partnerships);
+      expect(result.success).toBe(true);
+      expect(result.data).toBeDefined();
+      expect(result.data).toHaveLength(1);
+      expect(supabase.from).toHaveBeenCalledWith('partnerships');
+      expect(mockSupabaseQuery.select).toHaveBeenCalledWith('*');
     });
 
     it('should return empty array if no partnerships', async () => {
-      SecureStorageService.getItem.mockResolvedValue(null);
-
-      const result = await PartnershipService.getAllPartnerships();
-
-      expect(result).toEqual([]);
-    });
+      // Clear cache by calling clearAllPartnerships first
+      await PartnershipService.clearAllPartnerships();
 
-    it('should handle non-array data gracefully', async () => {
-      SecureStorageService.getItem.mockResolvedValue('invalid');
+      mockSupabaseQuery.select.mockResolvedValue({
+        error: null,
+        data: [],
+      });
 
       const result = await PartnershipService.getAllPartnerships();
 
-      expect(result).toEqual([]);
+      expect(result.success).toBe(true);
+      expect(result.data).toEqual([]);
     });
 
-    it('should handle storage errors', async () => {
-      const consoleError = jest.spyOn(console, 'error').mockImplementation();
-      SecureStorageService.getItem.mockRejectedValue(new Error('Storage error'));
+    it('should handle Supabase errors', async () => {
+      // Clear cache first
+      await PartnershipService.clearAllPartnerships();
 
-      const result = await PartnershipService.getAllPartnerships();
+      mockSupabaseQuery.select.mockResolvedValue({
+        error: new Error('Database error'),
+        data: null,
+      });
 
-      expect(consoleError).toHaveBeenCalledWith('Error loading partnerships:', expect.any(Error));
-      expect(result).toEqual([]);
+      const result = await PartnershipService.getAllPartnerships();
 
-      consoleError.mockRestore();
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+      expect(result.error.code).toContain('PARTNERSHIP');
+      expect(result.error.code).toContain('GETALLPARTNERSHIPS');
     });
   });
 
   describe('savePartnership', () => {
-    it('should save new partnership to storage', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership]);
-
-      const newPartnership = { ...mockPendingPartnership, id: 'new_partnership' };
-      const result = await PartnershipService.savePartnership(newPartnership);
-
-      expect(SecureStorageService.setItem).toHaveBeenCalledWith('partnerships', [
-        mockPartnership,
-        newPartnership,
-      ]);
-      expect(result).toBe(true);
-    });
-
-    it('should handle empty partnerships list', async () => {
-      SecureStorageService.getItem.mockResolvedValue([]);
+    it('should save new partnership to Supabase', async () => {
+      mockSupabaseQuery.insert.mockResolvedValue({
+        error: null,
+      });
 
       const result = await PartnershipService.savePartnership(mockPartnership);
 
-      expect(SecureStorageService.setItem).toHaveBeenCalledWith('partnerships', [mockPartnership]);
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
+      expect(supabase.from).toHaveBeenCalledWith('partnerships');
+      expect(mockSupabaseQuery.insert).toHaveBeenCalled();
     });
 
     it('should handle save errors', async () => {
-      const consoleError = jest.spyOn(console, 'error').mockImplementation();
-      SecureStorageService.setItem.mockRejectedValue(new Error('Save error'));
+      mockSupabaseQuery.insert.mockResolvedValue({
+        error: new Error('Insert error'),
+      });
 
       const result = await PartnershipService.savePartnership(mockPartnership);
 
-      expect(consoleError).toHaveBeenCalledWith('Error saving partnership:', expect.any(Error));
-      expect(result).toBe(false);
-
-      consoleError.mockRestore();
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+      expect(result.error.code).toContain('PARTNERSHIP');
+      expect(result.error.code).toContain('SAVEPARTNERSHIP');
     });
   });
 
   describe('updatePartnership', () => {
     it('should update existing partnership', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership, mockPendingPartnership]);
+      // Setup fresh mock for this test
+      mockSupabaseQuery.update.mockResolvedValueOnce({
+        error: null,
+      });
+      mockSupabaseQuery.eq.mockResolvedValueOnce({
+        error: null,
+      });
 
       const updatedPartnership = {
         ...mockPartnership,
@@ -198,470 +253,313 @@ describe('PartnershipService', () => {
       };
       const result = await PartnershipService.updatePartnership(updatedPartnership);
 
-      expect(SecureStorageService.setItem).toHaveBeenCalledWith('partnerships', [
-        updatedPartnership,
-        mockPendingPartnership,
-      ]);
-      expect(result).toBe(true);
-    });
-
-    it('should return false if partnership not found', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership]);
-
-      const unknownPartnership = { ...mockPartnership, id: 'unknown_id' };
-      const result = await PartnershipService.updatePartnership(unknownPartnership);
-
-      expect(SecureStorageService.setItem).not.toHaveBeenCalled();
-      expect(result).toBe(false);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
+      expect(mockSupabaseQuery.update).toHaveBeenCalled();
+      expect(mockSupabaseQuery.eq).toHaveBeenCalledWith('id', updatedPartnership.id);
     });
 
     it('should handle update errors', async () => {
-      const consoleError = jest.spyOn(console, 'error').mockImplementation();
-      // First getAllPartnerships succeeds
-      SecureStorageService.getItem.mockResolvedValueOnce([mockPartnership]);
-      // setItem fails
-      SecureStorageService.setItem.mockRejectedValue(new Error('Update error'));
+      mockSupabaseQuery.update.mockResolvedValue({
+        error: new Error('Update error'),
+      });
 
       const result = await PartnershipService.updatePartnership(mockPartnership);
 
-      expect(consoleError).toHaveBeenCalledWith('Error updating partnership:', expect.any(Error));
-      expect(result).toBe(false);
-
-      consoleError.mockRestore();
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+      expect(result.error.code).toContain('PARTNERSHIP');
+      expect(result.error.code).toContain('UPDATEPARTNERSHIP');
     });
   });
 
   describe('createPartnershipInvite', () => {
     it('should create partnership invite for partner role', async () => {
-      SecureStorageService.getItem.mockResolvedValue([]);
+      mockSupabaseQuery.insert.mockResolvedValueOnce({
+        error: null,
+      });
+      mockSupabaseQuery.select.mockResolvedValueOnce({
+        error: null,
+        data: mockDatabasePartnership,
+      });
+      mockSupabaseQuery.single.mockResolvedValueOnce({
+        error: null,
+        data: mockDatabasePartnership,
+      });
 
       const result = await PartnershipService.createPartnershipInvite('user_123', 'partner');
 
-      expect(createPartnership).toHaveBeenCalledWith({
-        inviteSentBy: 'user_123',
-        adhdUserId: 'user_123',
-        partnerId: null,
-      });
-      expect(SecureStorageService.setItem).toHaveBeenCalled();
-      expect(result).toMatchObject({
-        inviteSentBy: 'user_123',
-        adhdUserId: 'user_123',
-      });
+      expect(result.success).toBe(true);
+      expect(result.data).toBeDefined();
+      expect(supabase.rpc).toHaveBeenCalledWith('generate_invite_code');
+      expect(createPartnership).toHaveBeenCalled();
     });
 
     it('should create partnership invite for adhd_user role', async () => {
-      SecureStorageService.getItem.mockResolvedValue([]);
-
-      const result = await PartnershipService.createPartnershipInvite('partner_456', 'adhd_user');
-
-      expect(createPartnership).toHaveBeenCalledWith({
-        inviteSentBy: 'partner_456',
-        adhdUserId: null,
-        partnerId: 'partner_456',
+      mockSupabaseQuery.insert.mockResolvedValueOnce({
+        error: null,
+      });
+      mockSupabaseQuery.select.mockResolvedValueOnce({
+        error: null,
+        data: mockDatabasePartnership,
       });
-      expect(result).toMatchObject({
-        inviteSentBy: 'partner_456',
-        partnerId: 'partner_456',
+      mockSupabaseQuery.single.mockResolvedValueOnce({
+        error: null,
+        data: mockDatabasePartnership,
       });
+
+      const result = await PartnershipService.createPartnershipInvite('user_123', 'adhd_user');
+
+      expect(result.success).toBe(true);
+      expect(result.data).toBeDefined();
     });
 
     it('should handle errors during invite creation', async () => {
-      const consoleError = jest.spyOn(console, 'error').mockImplementation();
-      // Mock createPartnership to throw an error
-      createPartnership.mockImplementation(() => {
-        throw new Error('Create error');
-      });
+      supabase.rpc.mockReturnValue({ error: new Error('RPC error'), data: null });
 
       const result = await PartnershipService.createPartnershipInvite('user_123', 'partner');
 
-      expect(consoleError).toHaveBeenCalledWith(
-        'Error creating partnership invite:',
-        expect.any(Error),
-      );
-      expect(result).toBeNull();
-
-      consoleError.mockRestore();
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+      expect(result.error.code).toContain('PARTNERSHIP');
+      expect(result.error.code).toContain('CREATEPARTNERSHIPINVITE');
     });
   });
 
   describe('acceptPartnershipInvite', () => {
-    it('should accept valid partnership invite as ADHD user', async () => {
-      const pendingInvite = {
-        ...mockPendingPartnership,
-        adhdUserId: null,
-        partnerId: 'partner_456',
-      };
-      SecureStorageService.getItem.mockResolvedValue([pendingInvite]);
-      UserStorageService.getUserById
-        .mockResolvedValueOnce(mockUser) // ADHD user
-        .mockResolvedValueOnce(mockPartner); // Partner
-
-      const result = await PartnershipService.acceptPartnershipInvite('ABC123', 'user_123');
+    it('should accept valid partnership invite', async () => {
+      // Mock finding the partnership
+      mockSupabaseQuery.select.mockResolvedValueOnce({
+        error: null,
+        data: null, // No data for select
+      });
+      mockSupabaseQuery.eq.mockResolvedValueOnce({
+        error: null,
+        data: null,
+      });
+      mockSupabaseQuery.single.mockResolvedValueOnce({
+        error: null,
+        data: {
+          ...mockDatabasePartnership,
+          status: 'pending',
+          partner_id: null,
+          accepted_at: null,
+        },
+      });
 
-      expect(result.success).toBe(true);
-      expect(result.partnership).toMatchObject({
-        adhdUserId: 'user_123',
-        partnerId: 'partner_456',
-        status: PARTNERSHIP_STATUS.ACTIVE,
+      // Mock updating the partnership
+      mockSupabaseQuery.update.mockResolvedValueOnce({
+        error: null,
+      });
+      mockSupabaseQuery.eq.mockResolvedValueOnce({
+        error: null,
+      });
+      mockSupabaseQuery.select.mockResolvedValueOnce({
+        error: null,
+      });
+      mockSupabaseQuery.single.mockResolvedValueOnce({
+        error: null,
+        data: mockDatabasePartnership,
       });
-      expect(acceptPartnership).toHaveBeenCalled();
-      expect(setUserPartner).toHaveBeenCalledTimes(2);
-      expect(UserStorageService.updateUser).toHaveBeenCalledTimes(2);
-    });
 
-    it('should accept valid partnership invite as partner', async () => {
-      const pendingInvite = {
-        ...mockPendingPartnership,
-        adhdUserId: 'user_123',
-        partnerId: null,
-      };
-      SecureStorageService.getItem.mockResolvedValue([pendingInvite]);
-      UserStorageService.getUserById
-        .mockResolvedValueOnce(mockUser) // ADHD user
-        .mockResolvedValueOnce(mockPartner); // Partner
+      UserStorageService.getUserById.mockResolvedValue(mockUser);
 
       const result = await PartnershipService.acceptPartnershipInvite('ABC123', 'partner_456');
 
       expect(result.success).toBe(true);
-      expect(result.partnership).toMatchObject({
-        adhdUserId: 'user_123',
-        partnerId: 'partner_456',
-        status: PARTNERSHIP_STATUS.ACTIVE,
-      });
+      expect(result.data).toBeDefined();
+      expect(acceptPartnership).toHaveBeenCalled();
     });
 
     it('should reject invalid invite code', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership]);
+      mockSupabaseQuery.single.mockResolvedValue({
+        error: new Error('Not found'),
+        data: null,
+      });
 
       const result = await PartnershipService.acceptPartnershipInvite('INVALID', 'user_123');
 
-      expect(result).toEqual({
-        success: false,
-        error: 'Invalid invite code',
-      });
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
     });
 
     it('should reject already used invite', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership]); // Already active
-
-      const result = await PartnershipService.acceptPartnershipInvite('ABC123', 'user_789');
-
-      expect(result).toEqual({
-        success: false,
-        error: 'Invite already used',
-      });
-    });
-
-    it('should reject if partnership already complete', async () => {
-      const completePartnership = {
-        ...mockPendingPartnership,
-        adhdUserId: 'user_123',
-        partnerId: 'partner_456',
-      };
-      SecureStorageService.getItem.mockResolvedValue([completePartnership]);
-
-      const result = await PartnershipService.acceptPartnershipInvite('ABC123', 'user_789');
-
-      expect(result).toEqual({
-        success: false,
-        error: 'Partnership already complete',
-      });
-    });
-
-    it('should handle errors during acceptance', async () => {
-      const consoleError = jest.spyOn(console, 'error').mockImplementation();
-      // First call succeeds to find the partnership
-      SecureStorageService.getItem.mockResolvedValueOnce([mockPendingPartnership]);
-      // acceptPartnership throws error
-      acceptPartnership.mockImplementation(() => {
-        throw new Error('Accept error');
+      mockSupabaseQuery.single.mockResolvedValue({
+        error: null,
+        data: mockDatabasePartnership, // Already active
       });
 
       const result = await PartnershipService.acceptPartnershipInvite('ABC123', 'user_123');
 
-      expect(consoleError).toHaveBeenCalledWith(
-        'Error accepting partnership invite:',
-        expect.any(Error),
-      );
-      expect(result).toEqual({
-        success: false,
-        error: 'Failed to accept invite',
-      });
-
-      consoleError.mockRestore();
-    });
-  });
-
-  describe('getPartnershipByUsers', () => {
-    it('should find partnership by user IDs (order 1)', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership, mockPendingPartnership]);
-
-      const result = await PartnershipService.getPartnershipByUsers('user_123', 'partner_456');
-
-      expect(result).toEqual(mockPartnership);
-    });
-
-    it('should find partnership by user IDs (order 2)', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership, mockPendingPartnership]);
-
-      const result = await PartnershipService.getPartnershipByUsers('partner_456', 'user_123');
-
-      expect(result).toEqual(mockPartnership);
-    });
-
-    it('should return null if partnership not found', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership]);
-
-      const result = await PartnershipService.getPartnershipByUsers('user_123', 'unknown_user');
-
-      expect(result).toBeNull();
-    });
-
-    it('should handle errors from getAllPartnerships gracefully', async () => {
-      const consoleError = jest.spyOn(console, 'error').mockImplementation();
-      // When getAllPartnerships encounters an error, it returns empty array
-      SecureStorageService.getItem.mockRejectedValue(new Error('Get error'));
-
-      const result = await PartnershipService.getPartnershipByUsers('user_123', 'partner_456');
-
-      // getAllPartnerships handles the error and returns [], so getPartnershipByUsers returns null
-      expect(consoleError).toHaveBeenCalledWith('Error loading partnerships:', expect.any(Error));
-      expect(result).toBeNull();
-
-      consoleError.mockRestore();
-    });
-  });
-
-  describe('getPartnershipByInviteCode', () => {
-    it('should find partnership by invite code', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership, mockPendingPartnership]);
-
-      const result = await PartnershipService.getPartnershipByInviteCode('ABC123');
-
-      expect(result).toEqual(mockPartnership);
-    });
-
-    it('should return null if invite code not found', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership]);
-
-      const result = await PartnershipService.getPartnershipByInviteCode('INVALID');
-
-      expect(result).toBeNull();
-    });
-
-    it('should handle errors from getAllPartnerships gracefully', async () => {
-      const consoleError = jest.spyOn(console, 'error').mockImplementation();
-      // When getAllPartnerships encounters an error, it returns empty array
-      SecureStorageService.getItem.mockRejectedValue(new Error('Get error'));
-
-      const result = await PartnershipService.getPartnershipByInviteCode('ABC123');
-
-      // getAllPartnerships handles the error and returns [], so getPartnershipByInviteCode returns null
-      expect(consoleError).toHaveBeenCalledWith('Error loading partnerships:', expect.any(Error));
-      expect(result).toBeNull();
-
-      consoleError.mockRestore();
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
     });
   });
 
   describe('getUserPartnerships', () => {
     it('should return all partnerships for a user', async () => {
-      const anotherPartnership = {
-        ...mockPartnership,
-        id: 'partnership_other',
-        adhdUserId: 'user_123',
-        partnerId: 'partner_789',
-      };
-      SecureStorageService.getItem.mockResolvedValue([
-        mockPartnership,
-        mockPendingPartnership,
-        anotherPartnership,
-      ]);
+      mockSupabaseQuery.or.mockResolvedValue({
+        error: null,
+        data: [mockDatabasePartnership],
+      });
 
       const result = await PartnershipService.getUserPartnerships('user_123');
 
-      expect(result).toHaveLength(3);
-      expect(result).toContain(mockPartnership);
-      expect(result).toContain(mockPendingPartnership);
-      expect(result).toContain(anotherPartnership);
-    });
-
-    it('should return partnerships where user is partner', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership, mockPendingPartnership]);
-
-      const result = await PartnershipService.getUserPartnerships('partner_456');
-
-      expect(result).toHaveLength(1);
-      expect(result).toContain(mockPartnership);
+      expect(result.success).toBe(true);
+      expect(result.data).toBeDefined();
+      expect(result.data).toHaveLength(1);
+      expect(mockSupabaseQuery.or).toHaveBeenCalledWith(
+        'adhd_user_id.eq.user_123,partner_id.eq.user_123',
+      );
     });
 
     it('should return empty array if no partnerships', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership]);
-
-      const result = await PartnershipService.getUserPartnerships('unknown_user');
+      // Clear cache first
+      await PartnershipService.clearAllPartnerships();
 
-      expect(result).toEqual([]);
-    });
-
-    it('should handle errors from getAllPartnerships gracefully', async () => {
-      const consoleError = jest.spyOn(console, 'error').mockImplementation();
-      // When getAllPartnerships encounters an error, it returns empty array
-      SecureStorageService.getItem.mockRejectedValue(new Error('Get error'));
-
-      const result = await PartnershipService.getUserPartnerships('user_123');
+      mockSupabaseQuery.select.mockResolvedValueOnce({
+        error: null,
+        data: [],
+      });
+      mockSupabaseQuery.or.mockResolvedValueOnce({
+        error: null,
+        data: [],
+      });
 
-      // getAllPartnerships handles the error and returns [], so getUserPartnerships also returns []
-      expect(consoleError).toHaveBeenCalledWith('Error loading partnerships:', expect.any(Error));
-      expect(result).toEqual([]);
+      const result = await PartnershipService.getUserPartnerships('user_999'); // Different user ID to avoid cache
 
-      consoleError.mockRestore();
+      expect(result.success).toBe(true);
+      expect(result.data).toEqual([]);
     });
   });
 
   describe('getActivePartnership', () => {
     it('should return active partnership for user', async () => {
-      const pausedPartnership = {
-        ...mockPartnership,
-        id: 'partnership_paused',
-        status: PARTNERSHIP_STATUS.PAUSED,
-      };
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership, pausedPartnership]);
+      mockSupabaseQuery.single.mockResolvedValue({
+        error: null,
+        data: mockDatabasePartnership,
+      });
 
       const result = await PartnershipService.getActivePartnership('user_123');
 
-      expect(result).toEqual(mockPartnership);
+      expect(result.success).toBe(true);
+      expect(result.data).toBeDefined();
+      expect(mockSupabaseQuery.eq).toHaveBeenCalledWith('status', 'active');
     });
 
     it('should return null if no active partnership', async () => {
-      const pausedPartnership = {
-        ...mockPartnership,
-        status: PARTNERSHIP_STATUS.PAUSED,
-      };
-      SecureStorageService.getItem.mockResolvedValue([pausedPartnership, mockPendingPartnership]);
-
-      const result = await PartnershipService.getActivePartnership('user_123');
-
-      expect(result).toBeNull();
-    });
-
-    it('should handle errors from getAllPartnerships gracefully', async () => {
-      const consoleError = jest.spyOn(console, 'error').mockImplementation();
-      // When getAllPartnerships encounters an error, it returns empty array
-      SecureStorageService.getItem.mockRejectedValue(new Error('Get error'));
+      mockSupabaseQuery.single.mockResolvedValue({
+        error: new Error('Not found'),
+        data: null,
+      });
 
       const result = await PartnershipService.getActivePartnership('user_123');
 
-      // getAllPartnerships handles the error and returns [], which leads to no active partnership
-      expect(consoleError).toHaveBeenCalledWith('Error loading partnerships:', expect.any(Error));
-      expect(result).toBeNull();
-
-      consoleError.mockRestore();
+      expect(result.success).toBe(true);
+      expect(result.data).toBeNull();
     });
   });
 
   describe('incrementPartnershipStat', () => {
     it('should increment partnership stat by 1', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership]);
+      supabase.rpc.mockReturnValue({ error: null });
 
       const result = await PartnershipService.incrementPartnershipStat(
         'partnership_123',
         'tasksCompleted',
       );
 
-      expect(updatePartnershipStats).toHaveBeenCalledWith(mockPartnership, {
-        tasksCompleted: 4, // 3 + 1
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
+      expect(supabase.rpc).toHaveBeenCalledWith('update_partnership_stats', {
+        partnership_id: 'partnership_123',
+        stat_key: 'tasksCompleted',
+        increment: 1,
       });
-      expect(SecureStorageService.setItem).toHaveBeenCalled();
-      expect(result).toBe(true);
     });
 
     it('should increment partnership stat by custom amount', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership]);
+      supabase.rpc.mockReturnValue({ error: null });
 
       const result = await PartnershipService.incrementPartnershipStat(
         'partnership_123',
-        'encouragementsSent',
+        'tasksCompleted',
         5,
       );
 
-      expect(updatePartnershipStats).toHaveBeenCalledWith(mockPartnership, {
-        encouragementsSent: 15, // 10 + 5
-      });
-      expect(result).toBe(true);
-    });
-
-    it('should handle missing stat gracefully', async () => {
-      const partnershipWithoutStat = {
-        ...mockPartnership,
-        stats: {},
-      };
-      SecureStorageService.getItem.mockResolvedValue([partnershipWithoutStat]);
-
-      const result = await PartnershipService.incrementPartnershipStat(
-        'partnership_123',
-        'newStat',
-      );
-
-      expect(updatePartnershipStats).toHaveBeenCalledWith(partnershipWithoutStat, {
-        newStat: 1, // 0 + 1
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
+      expect(supabase.rpc).toHaveBeenCalledWith('update_partnership_stats', {
+        partnership_id: 'partnership_123',
+        stat_key: 'tasksCompleted',
+        increment: 5,
       });
-      expect(result).toBe(true);
-    });
-
-    it('should return false if partnership not found', async () => {
-      SecureStorageService.getItem.mockResolvedValue([mockPartnership]);
-
-      const result = await PartnershipService.incrementPartnershipStat(
-        'unknown_id',
-        'tasksCompleted',
-      );
-
-      expect(updatePartnershipStats).not.toHaveBeenCalled();
-      expect(result).toBe(false);
     });
 
     it('should handle errors', async () => {
-      const consoleError = jest.spyOn(console, 'error').mockImplementation();
-      // First getAllPartnerships succeeds
-      SecureStorageService.getItem.mockResolvedValueOnce([mockPartnership]);
-      // updatePartnershipStats throws error
-      updatePartnershipStats.mockImplementation(() => {
-        throw new Error('Update stats error');
-      });
+      supabase.rpc.mockReturnValue({ error: new Error('RPC error') });
 
       const result = await PartnershipService.incrementPartnershipStat(
         'partnership_123',
         'tasksCompleted',
       );
 
-      expect(consoleError).toHaveBeenCalledWith(
-        'Error incrementing partnership stat:',
-        expect.any(Error),
-      );
-      expect(result).toBe(false);
-
-      consoleError.mockRestore();
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+      expect(result.error.code).toContain('PARTNERSHIP');
+      expect(result.error.code).toContain('INCREMENTPARTNERSHIPSTAT');
     });
   });
 
   describe('clearAllPartnerships', () => {
-    it('should clear all partnerships from storage', async () => {
+    it('should clear all partnerships from Supabase', async () => {
+      mockSupabaseQuery.delete.mockResolvedValueOnce({
+        error: null,
+      });
+      mockSupabaseQuery.neq.mockResolvedValueOnce({
+        error: null,
+      });
+
       const result = await PartnershipService.clearAllPartnerships();
 
-      expect(SecureStorageService.removeItem).toHaveBeenCalledWith('partnerships');
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
+      expect(mockSupabaseQuery.delete).toHaveBeenCalled();
+      expect(mockSupabaseQuery.neq).toHaveBeenCalledWith(
+        'id',
+        '00000000-0000-0000-0000-000000000000',
+      );
     });
 
     it('should handle clear errors', async () => {
-      const consoleError = jest.spyOn(console, 'error').mockImplementation();
-      SecureStorageService.removeItem.mockRejectedValue(new Error('Clear error'));
+      mockSupabaseQuery.delete.mockResolvedValue({
+        error: new Error('Delete error'),
+      });
 
       const result = await PartnershipService.clearAllPartnerships();
 
-      expect(consoleError).toHaveBeenCalledWith('Error clearing partnerships:', expect.any(Error));
-      expect(result).toBe(false);
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+      expect(result.error.code).toContain('PARTNERSHIP');
+      expect(result.error.code).toContain('CLEARALLPARTNERSHIPS');
+    });
+  });
+
+  describe('subscribeToPartnershipUpdates', () => {
+    it('should create a realtime subscription', () => {
+      const mockChannel = {
+        on: jest.fn().mockReturnThis(),
+        subscribe: jest.fn().mockReturnThis(),
+      };
+      supabase.channel.mockReturnValue(mockChannel);
+
+      const callback = jest.fn();
+      const result = PartnershipService.subscribeToPartnershipUpdates('user_123', callback);
 
-      consoleError.mockRestore();
+      expect(supabase.channel).toHaveBeenCalledWith('partnerships-user_123');
+      expect(mockChannel.on).toHaveBeenCalled();
+      expect(mockChannel.subscribe).toHaveBeenCalled();
+      expect(result).toBe(mockChannel);
     });
   });
 });
diff --git a/src/services/__tests__/SettingsService.test.js b/src/services/__tests__/SettingsService.test.js
index 1f17eb9..da10538 100644
--- a/src/services/__tests__/SettingsService.test.js
+++ b/src/services/__tests__/SettingsService.test.js
@@ -34,34 +34,34 @@ describe('SettingsService', () => {
 
       AsyncStorage.getItem.mockResolvedValue(JSON.stringify(storedSettings));
 
-      const settings = await settingsService.loadSettings();
+      const result = await settingsService.loadSettings();
 
       expect(AsyncStorage.getItem).toHaveBeenCalledWith('@adhd_todo_settings');
-      expect(settings.pomodoro.workDuration).toBe(30);
-      expect(settings.soundEnabled).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data.pomodoro.workDuration).toBe(30);
+      expect(result.data.soundEnabled).toBe(true);
     });
 
     it('should return default settings if nothing is stored', async () => {
       AsyncStorage.getItem.mockResolvedValue(null);
 
       const freshService = SettingsService.getInstance();
-      const settings = await freshService.loadSettings();
+      const result = await freshService.loadSettings();
 
-      expect(settings.pomodoro.workDuration).toBe(25);
-      expect(settings.pomodoro.breakDuration).toBe(5);
-      expect(settings.soundEnabled).toBe(false);
+      expect(result.success).toBe(true);
+      expect(result.data.pomodoro.workDuration).toBe(25);
+      expect(result.data.pomodoro.breakDuration).toBe(5);
+      expect(result.data.soundEnabled).toBe(false);
     });
 
-    it('should handle errors and return defaults', async () => {
+    it('should handle errors and return error result', async () => {
       AsyncStorage.getItem.mockRejectedValue(new Error('Storage error'));
 
-      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
-      const settings = await settingsService.loadSettings();
+      const result = await settingsService.loadSettings();
 
-      expect(consoleSpy).toHaveBeenCalledWith('Error loading settings:', expect.any(Error));
-      expect(settings.pomodoro.workDuration).toBe(25);
-
-      consoleSpy.mockRestore();
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+      expect(result.error.code).toContain('SETTINGSSERVICE_LOADSETTINGS_ERROR');
     });
   });
 
@@ -88,7 +88,8 @@ describe('SettingsService', () => {
 
       const result = await settingsService.saveSettings(newSettings);
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
       expect(AsyncStorage.setItem).toHaveBeenCalledWith(
         '@adhd_todo_settings',
         JSON.stringify(newSettings),
@@ -98,13 +99,11 @@ describe('SettingsService', () => {
     it('should handle save errors', async () => {
       AsyncStorage.setItem.mockRejectedValue(new Error('Storage error'));
 
-      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
       const result = await settingsService.saveSettings({});
 
-      expect(result).toBe(false);
-      expect(consoleSpy).toHaveBeenCalledWith('Error saving settings:', expect.any(Error));
-
-      consoleSpy.mockRestore();
+      expect(result.success).toBe(false);
+      expect(result.error).toBeDefined();
+      expect(result.error.code).toContain('SETTINGSSERVICE_SAVESETTINGS_ERROR');
     });
   });
 
@@ -124,7 +123,8 @@ describe('SettingsService', () => {
         breakDuration: 10,
       });
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
 
       const savedSettings = JSON.parse(AsyncStorage.setItem.mock.calls[0][1]);
       expect(savedSettings.pomodoro.workDuration).toBe(50);
@@ -143,7 +143,8 @@ describe('SettingsService', () => {
 
       const result = await settingsService.updateSetting('soundEnabled', true);
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
 
       const savedSettings = JSON.parse(AsyncStorage.setItem.mock.calls[0][1]);
       expect(savedSettings.soundEnabled).toBe(true);
@@ -173,7 +174,8 @@ describe('SettingsService', () => {
 
       const result = await settingsService.resetToDefaults();
 
-      expect(result).toBe(true);
+      expect(result.success).toBe(true);
+      expect(result.data).toBe(true);
 
       const savedSettings = JSON.parse(AsyncStorage.setItem.mock.calls[0][1]);
       expect(savedSettings.pomodoro.workDuration).toBe(25);
@@ -215,4 +217,63 @@ describe('SettingsService', () => {
       expect(SettingsService.validateTaskLimit(11)).toBe(false);
     });
   });
+
+  describe('compatibility methods', () => {
+    it('should load settings with backward compatibility', async () => {
+      const storedSettings = {
+        pomodoro: {
+          workDuration: 30,
+          breakDuration: 10,
+        },
+        soundEnabled: true,
+      };
+
+      AsyncStorage.getItem.mockResolvedValue(JSON.stringify(storedSettings));
+
+      const settings = await settingsService.loadSettingsCompat();
+
+      expect(settings.pomodoro.workDuration).toBe(30);
+      expect(settings.soundEnabled).toBe(true);
+    });
+
+    it('should return defaults on error with loadSettingsCompat', async () => {
+      AsyncStorage.getItem.mockRejectedValue(new Error('Storage error'));
+
+      const settings = await settingsService.loadSettingsCompat();
+
+      expect(settings.pomodoro.workDuration).toBe(25);
+      expect(settings.soundEnabled).toBe(false);
+    });
+
+    it('should save settings with backward compatibility', async () => {
+      AsyncStorage.setItem.mockResolvedValue();
+
+      const result = await settingsService.saveSettingsCompat({
+        pomodoro: {
+          workDuration: 45,
+          breakDuration: 15,
+          longBreakDuration: 30,
+          longBreakAfter: 3,
+          autoStartBreaks: true,
+          autoStartWork: false,
+          breakReminders: true,
+          reminderInterval: 60,
+        },
+        soundEnabled: true,
+        hapticEnabled: false,
+        taskLimit: 7,
+        celebrationAnimations: true,
+      });
+
+      expect(result).toBe(true);
+    });
+
+    it('should return false on save error with saveSettingsCompat', async () => {
+      AsyncStorage.setItem.mockRejectedValue(new Error('Storage error'));
+
+      const result = await settingsService.saveSettingsCompat({});
+
+      expect(result).toBe(false);
+    });
+  });
 });
diff --git a/src/services/__tests__/SupabaseAuthService.test.js b/src/services/__tests__/SupabaseAuthService.test.js
index 5b1c756..2e4ea42 100644
--- a/src/services/__tests__/SupabaseAuthService.test.js
+++ b/src/services/__tests__/SupabaseAuthService.test.js
@@ -11,7 +11,16 @@ jest.mock('../CryptoService');
 jest.mock('../RateLimiter');
 jest.mock('expo-secure-store');
 jest.mock('../SecureLogger');
-jest.mock('../UserStorageService');
+jest.mock('../UserStorageService', () => {
+  const mockLogout = jest.fn().mockResolvedValue();
+  return {
+    default: {
+      logout: mockLogout,
+      getCurrentUser: jest.fn().mockResolvedValue(null),
+    },
+    __esModule: true,
+  };
+});
 
 // Mock SupabaseService with a proper structure
 jest.mock('../SupabaseService', () => ({
@@ -82,6 +91,8 @@ describe('SupabaseAuthService', () => {
     RateLimiter.recordLoginAttempt = jest.fn();
     RateLimiter.getLockoutEndTime = jest.fn(() => null);
 
+    // UserStorageService is mocked at the top of the file
+
     // SecureStore mocks are already set up by jest.mock('expo-secure-store')
 
     // Create service instance
diff --git a/src/services/__tests__/UserStorageService.test.js b/src/services/__tests__/UserStorageService.test.js
index b96ea56..4ea3a92 100644
--- a/src/services/__tests__/UserStorageService.test.js
+++ b/src/services/__tests__/UserStorageService.test.js
@@ -1,6 +1,10 @@
 // ABOUTME: Tests for simplified UserStorageService that only uses Supabase
 // Follows TDD approach - tests written before implementation
 
+import { createMockUser } from '../../../tests/utils';
+import { NotificationPreference } from '../../types/user.types';
+import * as SecureStore from 'expo-secure-store';
+
 // Mock dependencies first
 jest.mock('../SupabaseService', () => ({
   supabase: {
@@ -12,9 +16,6 @@ jest.mock('expo-secure-store');
 jest.mock('../SecureLogger');
 
 import { supabase } from '../SupabaseService';
-import * as SecureStore from 'expo-secure-store';
-import { createMockUser } from '../../../tests/utils';
-import { NotificationPreference } from '../../types/user.types';
 import UserStorageService from '../UserStorageService';
 
 describe('UserStorageService (Simplified Supabase-only)', () => {
@@ -30,9 +31,6 @@ describe('UserStorageService (Simplified Supabase-only)', () => {
     SecureStore.getItemAsync.mockResolvedValue(null);
     SecureStore.deleteItemAsync.mockResolvedValue();
 
-    // Clear the service cache by calling logout
-    await UserStorageService.logout();
-
     // Setup mock user
     mockUser = createMockUser({
       id: 'user-123',
